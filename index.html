<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>åƒè±†äººï¼šç°ä»£é‡åˆ¶</title>
    <link href="https://fonts.googleapis.com/css2?family=Varela+Round&family=ZCOOL+KuaiLe&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-light: #f4f7f6;
            --game-bg: #1e293b;
            --wall-color: #334155;
            --accent: #3b82f6;
            --text-main: #1e293b;
        }

        body {
            background-color: var(--bg-light);
            color: var(--text-main);
            font-family: 'Varela Round', sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            margin: 0;
            overflow: hidden;
            user-select: none;
        }

        #game-wrapper {
            position: relative;
            padding: 20px;
            background: #fff;
            border-radius: 24px;
            box-shadow: 
                0 20px 50px rgba(0,0,0,0.1), 
                0 4px 12px rgba(0,0,0,0.05);
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 700px; /* å›ºå®šå®½åº¦ */
        }

        canvas {
            background-color: var(--game-bg);
            border-radius: 16px;
            display: block;
            cursor: default;
        }

        /* HUD */
        #hud {
            display: flex;
            justify-content: space-between;
            width: 100%;
            margin-bottom: 20px;
            padding: 0 10px;
            box-sizing: border-box;
        }

        .stat-card {
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .stat-label {
            font-size: 12px;
            font-weight: bold;
            color: #94a3b8;
            letter-spacing: 1px;
            text-transform: uppercase;
            margin-bottom: 4px;
        }

        .stat-value {
            font-size: 24px;
            font-weight: bold;
            color: var(--text-main);
        }
        .stat-subvalue {
            font-size: 12px;
            color: #94a3b8;
            margin-top: 2px;
            letter-spacing: 0.5px;
        }

        /* æš‚åœæŒ‰é’® (æ•´åˆè¿› HUD) */
        #pause-btn {
            position: relative; /* ä¸å†ç»å¯¹å®šä½ */
            background: #f1f5f9;
            border: 2px solid #e2e8f0;
            width: 44px;
            height: 44px;
            border-radius: 12px;
            color: #64748b;
            font-size: 16px;
            cursor: pointer;
            display: none; /* JS æ§åˆ¶æ˜¾ç¤º */
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
            margin-left: 15px; /* ä¸ Level æ‹‰å¼€è·ç¦» */
            box-shadow: none;
            padding: 0; /* è¦†ç›–é€šç”¨æŒ‰é’®çš„å†…è¾¹è·ï¼Œä¿æŒæ–¹å½¢å°ºå¯¸ */
            gap: 0;
            line-height: 1;
            flex-shrink: 0;
        }
        #pause-btn svg {
            width: 20px;
            height: 20px;
            pointer-events: none; /* é˜²æ­¢ç‚¹å‡»äº‹ä»¶è¢« SVG æ•è· */
        }
        #pause-btn:hover {
            background: #fff;
            border-color: #3b82f6;
            color: #3b82f6;
            transform: translateY(-2px);
            box-shadow: 0 4px 10px rgba(59, 130, 246, 0.2);
        }

        /* ç»Ÿä¸€å¼¹çª—æ ·å¼ */
        .overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(255, 255, 255, 0.95); /* ä¸é€æ˜åº¦é«˜ä¸€ç‚¹ï¼Œä½œä¸ºä¸»ç•Œé¢ */
            backdrop-filter: blur(10px);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            text-align: center;
            z-index: 50;
            border-radius: 24px;
            padding: 40px;
            box-sizing: border-box;
        }

        .overlay.glass {
            background: rgba(255, 255, 255, 0.8); /* æ¸¸æˆå†…å¼¹çª—åŠé€æ˜ */
        }

        .title {
            font-size: 56px;
            font-weight: 800;
            margin-bottom: 10px;
            background: linear-gradient(135deg, #3b82f6, #8b5cf6);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            letter-spacing: -2px;
        }

        .subtitle {
            font-size: 16px;
            color: #64748b;
            margin-bottom: 40px;
            line-height: 1.6;
            max-width: 400px;
        }

        /* ä¸»æ ‡é¢˜æ›´è´´è¿‘è¡—æœºæ„Ÿ */
        .brand-title {
            font-family: 'ZCOOL KuaiLe', 'Varela Round', sans-serif;
            font-size: 64px;
            color: #fbbf24;
            letter-spacing: 6px;
            text-shadow:
                0 8px 0 #1e293b,
                0 0 18px rgba(251, 191, 36, 0.55);
            margin-bottom: 14px;
        }
        .brand-title .brand-chomp {
            display: inline-block;
            color: #fbbf24;
            animation: glyphGlow 1.6s ease-in-out infinite;
        }
        .brand-title .brand-chomp:nth-child(1) { animation-delay: 0s; }
        .brand-title .brand-chomp:nth-child(2) { animation-delay: 0.2s; }
        .brand-title .brand-chomp:nth-child(3) { animation-delay: 0.4s; }
        @keyframes glyphGlow {
            0% { color: #fbbf24; filter: drop-shadow(0 8px 0 #1e293b); }
            50% { color: #fde047; filter: drop-shadow(0 10px 6px rgba(0,0,0,0.35)); }
            100% { color: #fbbf24; filter: drop-shadow(0 8px 0 #1e293b); }
        }
        .brand-tagline {
            display: inline-block;
            padding: 6px 14px;
            border-radius: 999px;
            background: linear-gradient(120deg, #0ea5e9, #8b5cf6);
            color: #fff;
            font-size: 12px;
            letter-spacing: 2px;
            text-transform: uppercase;
            box-shadow: 0 8px 20px rgba(59, 130, 246, 0.25);
        }

        /* èœå•è£…é¥°åŠ¨ç”» */
        .menu-decoration {
            position: relative;
            width: 200px;
            height: 100px;
            margin-bottom: 20px;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .giant-pacman {
            width: 60px;
            height: 60px;
            background: #fbbf24;
            border-radius: 50%;
            position: relative;
            clip-path: polygon(100% 0%, 100% 100%, 50% 50%, 0% 100%, 0% 0%); /* åˆå§‹å½¢çŠ¶ */
            animation: chomp 0.6s infinite alternate linear;
            box-shadow: 0 0 20px rgba(251, 191, 36, 0.6);
        }

        .floating-ghost {
            width: 40px;
            height: 40px;
            margin: 0 10px;
            border-radius: 50% 50% 0 0;
            position: relative;
            animation: floatGhost 2s infinite ease-in-out;
        }
        .floating-ghost::after {
            content: '';
            position: absolute;
            bottom: -5px;
            left: 0;
            width: 100%;
            height: 10px;
            background: inherit;
            mask: radial-gradient(circle at 5px 0, transparent 5px, black 5.5px) repeat-x;
            mask-size: 10px 10px;
            -webkit-mask: radial-gradient(circle at 5px 0, transparent 5px, black 5.5px) repeat-x;
            -webkit-mask-size: 10px 10px;
        }
        /* é¬¼é­‚çœ¼ç› */
        .floating-ghost::before {
            content: '';
            position: absolute;
            top: 12px;
            left: 8px;
            width: 8px;
            height: 8px;
            background: #fff;
            border-radius: 50%;
            box-shadow: 16px 0 0 #fff; /* ç¬¬äºŒåªçœ¼ */
        }

        @keyframes chomp {
            0% { clip-path: polygon(100% 0%, 100% 100%, 50% 50%, 0% 100%, 0% 0%); transform: rotate(0deg); }
            100% { clip-path: polygon(100% 20%, 100% 80%, 50% 50%, 0% 100%, 0% 0%); transform: rotate(0deg); } 
            /* è¿™é‡Œç®€åŒ–äº†clip-pathæ¨¡æ‹Ÿå˜´å·´å¼€åˆï¼Œç¨å¾®æœ‰ç‚¹æŠ½è±¡ä½†å¤Ÿç”¨ */
        }
        /* æ›´å®Œç¾çš„ CSS å˜´å·´åŠ¨ç”»å…¶å®æ˜¯ç”¨ conic-gradientï¼Œä½† clip-path æ›´ç®€å• */
        /* è®©æˆ‘ä»¬ç”¨ä¸€ä¸ªæ›´ç®€å•çš„ CSS åƒè±†äººå®ç°ï¼šåˆ©ç”¨ border */
        .giant-pacman-v2 {
            width: 0; 
            height: 0; 
            border-right: 30px solid transparent; 
            border-top: 30px solid #fbbf24; 
            border-left: 30px solid #fbbf24; 
            border-bottom: 30px solid #fbbf24; 
            border-radius: 30px; 
            animation: chomp-v2 0.4s infinite alternate;
            box-shadow: 0 0 20px rgba(251, 191, 36, 0.6);
        }
        @keyframes chomp-v2 {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(45deg); border-right: 30px solid transparent; } /* è¿™é‡Œçš„åŠ¨ç”»æœ‰ç‚¹éš¾åšå®Œç¾ï¼Œè¿˜æ˜¯ç”¨ rotate + clip-path ç»„åˆ */
        }

        /* æœ€ç»ˆæ–¹æ¡ˆï¼šSVG æˆ–è€… Canvas å…¶å®æœ€å¥½ï¼Œä½† CSS ä¹Ÿèƒ½åš */
        .css-pacman {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            background: conic-gradient(#fbbf24 30deg, #fbbf24 330deg, transparent 330deg, transparent 360deg);
            animation: bite 0.5s infinite alternate;
        }
        @keyframes bite {
            0% { background: conic-gradient(#fbbf24 30deg, #fbbf24 330deg, transparent 330deg, transparent 360deg); transform: rotate(0deg); }
            100% { background: conic-gradient(#fbbf24 0deg, #fbbf24 360deg, transparent 360deg, transparent 360deg); transform: rotate(0deg); }
        }

        @keyframes floatGhost {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-10px); }
        }

        /* æŒ‰é’®ç»„ */
        .btn-group {
            display: flex;
            flex-direction: column;
            gap: 15px;
            width: 100%;
            max-width: 250px;
        }

        button {
            font-family: 'Varela Round', sans-serif;
            background: #3b82f6;
            color: white;
            border: none;
            padding: 16px 32px;
            font-size: 18px;
            font-weight: bold;
            border-radius: 16px;
            cursor: pointer;
            transition: all 0.2s ease;
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.3);
            width: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
        }

        button:hover {
            background: #2563eb;
            transform: translateY(-2px);
            box-shadow: 0 6px 16px rgba(59, 130, 246, 0.4);
        }

        button.secondary {
            background: #e2e8f0;
            color: #475569;
            box-shadow: none;
        }
        button.secondary:hover {
            background: #cbd5e1;
        }

        /* å…³å¡é€‰æ‹©ç½‘æ ¼ */
        #level-grid {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 10px;
            margin-bottom: 30px;
        }
        .level-btn {
            width: 50px;
            height: 50px;
            padding: 0;
            font-size: 18px;
            background: #e2e8f0;
            color: #64748b;
            box-shadow: none;
        }
        .level-btn.locked {
            background: #f1f5f9;
            color: #cbd5e1;
            cursor: not-allowed;
        }
        .level-btn:not(.locked):hover {
            background: #3b82f6;
            color: white;
        }

        /* è§„åˆ™è¯´æ˜ */
        .rules-list {
            text-align: left;
            font-size: 14px;
            color: #475569;
            margin-bottom: 30px;
            line-height: 2;
            background: #f8fafc;
            padding: 20px;
            border-radius: 12px;
            width: 100%;
        }
        .rules-list i {
            width: 20px;
            text-align: center;
            margin-right: 8px;
        }

        #msg-float {
            position: absolute;
            top: 55%; /* ç¨å¾®é ä¸‹ï¼Œé¿å¼€ä¸­å¿ƒ */
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 60px;
            font-weight: 800;
            color: #fff;
            text-shadow: 0 4px 10px rgba(0,0,0,0.2);
            display: none;
            pointer-events: none;
            z-index: 20;
        }

        .hidden { display: none !important; }

        /* é¡µé¢åº•éƒ¨ç½²å */
        .credit-footer {
            position: absolute;
            bottom: 14px;
            left: 0;
            right: 0;
            text-align: center;
            font-size: 11px;
            color: #cbd5e1;
            pointer-events: none;
        }
    </style>
</head>
<body>

    <div id="game-wrapper">
        <div id="hud">
            <div class="stat-card" style="align-items: flex-start; width: 120px;">
                <div class="stat-label">ç”Ÿå‘½</div>
                <div id="ui-lives" class="stat-value" style="color: #ef4444; font-size: 20px;">â¤ï¸â¤ï¸â¤ï¸</div>
            </div>
            <div class="stat-card">
                <div class="stat-label">å¾—åˆ†</div>
                <div id="ui-score" class="stat-value" style="color: #3b82f6;">0</div>
                <div id="ui-high-score" class="stat-subvalue">æœ€é«˜ 0</div>
            </div>
            <!-- å³ä¾§ç»„åˆï¼šå…³å¡ + æš‚åœ -->
            <div style="display: flex; align-items: center; width: 120px; justify-content: flex-end;">
                <div class="stat-card" style="align-items: flex-end; margin-right: 0;">
                    <div class="stat-label">å…³å¡</div>
                    <div id="ui-level" class="stat-value">1</div>
                    <div id="ui-run-mode" class="stat-subvalue hidden">å…¨ç¨‹ 1â†’20</div>
                </div>
                <button id="pause-btn" onclick="game.pauseGame()">
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor"><rect x="6" y="4" width="4" height="16"/><rect x="14" y="4" width="4" height="16"/></svg>
                </button>
            </div>
        </div>

        <div style="position: relative;">
            <canvas id="gameCanvas" width="665" height="630"></canvas>
            <div id="msg-float">å‡†å¤‡</div>
        </div>

        <!-- 1. ä¸»èœå• -->
        <div id="screen-menu" class="overlay">
            <div class="menu-decoration">
                <div class="floating-ghost" style="background: #ef4444; animation-delay: 0s;"></div>
                <div class="css-pacman" style="margin: 0 20px;"></div>
                <div class="floating-ghost" style="background: #3b82f6; animation-delay: 1s;"></div>
            </div>
            <div class="title" style="background: none; -webkit-text-fill-color: initial;">
                <div class="brand-title"><span class="brand-chomp">åƒ</span><span class="brand-chomp">è±†</span><span class="brand-chomp">äºº</span></div>
                <div class="brand-tagline">PAC-MAN</div>
            </div>
            
            <div class="btn-group">
                <button onclick="game.startFullRun()">
                    <svg width="18" height="18" viewBox="0 0 24 24" fill="currentColor"><path d="M5 3v18l15-9z"/></svg> å…¨ç¨‹æŒ‘æˆ˜
                </button>
                <button onclick="game.showLevelSelect()">
                    <svg width="18" height="18" viewBox="0 0 24 24" fill="currentColor"><path d="M8 5v14l11-7z"/></svg> å¼€å§‹æ¸¸æˆ
                </button>
                <button class="secondary" onclick="game.showRules()">
                    <svg width="18" height="18" viewBox="0 0 24 24" fill="currentColor"><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm1 15h-2v-6h2v6zm0-8h-2V7h2v2z"/></svg> ç©æ³•è¯´æ˜
                </button>
            </div>
            <div style="margin-top: 30px; font-size: 12px; color: #94a3b8;">
                æœ€é«˜è§£é”å…³å¡ï¼š<span id="menu-max-level">1</span>
                <br/>å…¨ç¨‹æœ€ä½³è¿›åº¦ï¼š<span id="menu-best-run">1</span>
            </div>
        </div>

        <!-- 2. å…³å¡é€‰æ‹© -->
        <div id="screen-levels" class="overlay hidden">
            <div class="title" style="font-size: 32px;">é€‰æ‹©å…³å¡</div>
            <div class="subtitle">è‡ªç”±é€‰æ‹©ä»»æ„å…³å¡å¼€å§‹æ™®é€šæ¨¡å¼ã€‚</div>
            <div id="level-grid">
                <!-- JSç”Ÿæˆ -->
            </div>
            <button class="secondary" style="width: auto; padding: 10px 30px;" onclick="game.showMenu()">è¿”å›</button>
        </div>

        <!-- 3. è§„åˆ™è¯´æ˜ -->
        <div id="screen-rules" class="overlay hidden">
            <div class="title" style="font-size: 32px;">ç©æ³•è¯´æ˜</div>
            <div class="rules-list">
                <div><span style="margin-right: 8px;">âŒ¨ï¸</span> ä½¿ç”¨æ–¹å‘é”®ç§»åŠ¨</div>
                <div><span style="margin-right: 8px;">ğŸŸ¡</span> åƒå®Œæ‰€æœ‰è±†å­å³å¯è¿‡å…³</div>
                <div><span style="margin-right: 8px;">ğŸŸ£</span> åƒå¤§åŠ›ä¸¸å¯ä»¥ååƒå¹½çµï¼</div>
                <div><span style="margin-right: 8px;">ğŸ‘»</span> è¿œç¦»å¹½çµï¼ˆç¢°åˆ°ä¼šå¤±å» 1 æ¡å‘½ï¼‰</div>
                <div><span style="margin-right: 8px;">â¤ï¸</span> æ¯å±€æœ‰ 3 æ¡å‘½</div>
                <div><span style="margin-right: 8px;">âš¡</span> æ¯ä¸€å…³é€Ÿåº¦éƒ½ä¼šæ›´å¿«</div>
                <div><span style="margin-right: 8px;">ğŸ</span> è¯•è¯•å…¨ç¨‹æŒ‘æˆ˜ï¼Œä»ç¬¬ 1 å…³è·‘åˆ°ç¬¬ 20 å…³ï¼Œå†²å‡»ä½ çš„æœ€ä½³çºªå½•ï¼</div>
            </div>
            <button onclick="game.showMenu()">çŸ¥é“äº†ï¼</button>
            <div class="credit-footer">åˆ¶ä½œï¼šç¾Šæ‘ç¬¬ä¸€ç¾Š</div>
        </div>

        <!-- 4. æš‚åœèœå• -->
        <div id="screen-paused" class="overlay glass hidden">
            <div class="title" style="font-size: 40px;">å·²æš‚åœ</div>
            <div class="btn-group">
                <button onclick="game.resumeGame()">
                    <svg width="18" height="18" viewBox="0 0 24 24" fill="currentColor"><path d="M8 5v14l11-7z"/></svg> ç»§ç»­æ¸¸æˆ
                </button>
                <button class="secondary" onclick="game.restartLevel()">
                    <svg width="18" height="18" viewBox="0 0 24 24" fill="currentColor"><path d="M17.65 6.35C16.2 4.9 14.21 4 12 4c-4.42 0-7.99 3.58-7.99 8s3.57 8 7.99 8c3.73 0 6.84-2.55 7.73-6h-2.08c-.82 2.33-3.04 4-5.65 4-3.31 0-6-2.69-6-6s2.69-6 6-6c1.66 0 3.14.69 4.22 1.78L13 11h7V4l-2.35 2.35z"/></svg> é‡ç©æœ¬å…³
                </button>
                <button class="secondary" onclick="game.quitToMenu()">
                    <svg width="18" height="18" viewBox="0 0 24 24" fill="currentColor"><path d="M10 20v-6h4v6h5v-8h3L12 3 2 12h3v8z"/></svg> è¿”å›èœå•
                </button>
            </div>
        </div>

        <!-- 5. æ¸¸æˆç»“æŸ -->
        <div id="screen-gameover" class="overlay glass hidden">
            <div class="title" style="color: #ef4444; -webkit-text-fill-color: #ef4444; background: none;">æ¸¸æˆç»“æŸ</div>
            <div class="subtitle">æœ€ç»ˆå¾—åˆ†ï¼š<span id="end-score" style="font-weight: bold; color: #1e293b; font-size: 24px;">0</span></div>
            <div id="end-run-best" class="subtitle hidden">å…¨ç¨‹æœ€ä½³è¿›åº¦ï¼š<span id="end-run-best-value" style="font-weight: bold; color: #1e293b;">1</span></div>
            <div class="btn-group">
                <button onclick="game.restartGame()">
                    <svg width="18" height="18" viewBox="0 0 24 24" fill="currentColor"><path d="M17.65 6.35C16.2 4.9 14.21 4 12 4c-4.42 0-7.99 3.58-7.99 8s3.57 8 7.99 8c3.73 0 6.84-2.55 7.73-6h-2.08c-.82 2.33-3.04 4-5.65 4-3.31 0-6-2.69-6-6s2.69-6 6-6c1.66 0 3.14.69 4.22 1.78L13 11h7V4l-2.35 2.35z"/></svg> å†è¯•ä¸€æ¬¡
                </button>
                <button class="secondary" onclick="game.quitToMenu()">
                    <svg width="18" height="18" viewBox="0 0 24 24" fill="currentColor"><path d="M10 20v-6h4v6h5v-8h3L12 3 2 12h3v8z"/></svg> è¿”å›èœå•
                </button>
            </div>
        </div>

        <!-- 5.5 å…¨ç¨‹æ¨¡å¼å®Œæˆ -->
        <div id="screen-runcomplete" class="overlay glass hidden">
            <div class="title" style="color: #10b981; -webkit-text-fill-color: #10b981; background: none;">å…¨ç¨‹é€šå…³</div>
            <div class="subtitle">æœ¬æ¬¡åˆ°è¾¾ç¬¬ <span id="runcomplete-level">20</span> å…³ï¼Œå¾—åˆ† <span id="runcomplete-score" style="font-weight: bold; color: #1e293b;">0</span></div>
            <div class="subtitle">å…¨ç¨‹æœ€ä½³è¿›åº¦ï¼š<span id="runcomplete-best" style="font-weight: bold; color: #1e293b;">1</span></div>
            <div class="btn-group">
                <button onclick="game.restartGame()">
                    <svg width="18" height="18" viewBox="0 0 24 24" fill="currentColor"><path d="M17.65 6.35C16.2 4.9 14.21 4 12 4c-4.42 0-7.99 3.58-7.99 8s3.57 8 7.99 8c3.73 0 6.84-2.55 7.73-6h-2.08c-.82 2.33-3.04 4-5.65 4-3.31 0-6-2.69-6-6s2.69-6 6-6c1.66 0 3.14.69 4.22 1.78L13 11h7V4l-2.35 2.35z"/></svg> å†è·‘ä¸€é
                </button>
                <button class="secondary" onclick="game.quitToMenu()">
                    <svg width="18" height="18" viewBox="0 0 24 24" fill="currentColor"><path d="M10 20v-6h4v6h5v-8h3L12 3 2 12h3v8z"/></svg> è¿”å›èœå•
                </button>
            </div>
        </div>

        <!-- 6. å…³å¡å®Œæˆ -->
        <div id="screen-levelup" class="overlay glass hidden">
            <div class="title" style="color: #10b981; -webkit-text-fill-color: #10b981; background: none;">å…³å¡å®Œæˆï¼</div>
            <div class="subtitle">ä¸‹ä¸€å…³ï¼š<span id="next-level-num">2</span></div>
        </div>
    </div>

    <script>
        const TILE_SIZE = 35; 
        const BASE_SPEED = 0.03; 
        const RUN_MAX_LEVEL = 20; // å…¨ç¨‹æ¨¡å¼çš„ç»ˆç‚¹å…³å¡
        
        const LEVEL_THEMES = [
            { wall: '#475569', bg: '#1e293b' }, 
            { wall: '#7c2d12', bg: '#451a03' }, 
            { wall: '#10b981', bg: '#022c22' }, 
            { wall: '#4c1d95', bg: '#2e1065' }, 
            { wall: '#831843', bg: '#500724' }  
        ];

        const RAW_MAP = [
            [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
            [1,3,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,3,1], // è§’è½å˜æˆ 3 (å¤§åŠ›ä¸¸)
            [1,0,1,1,0,1,1,1,0,1,0,1,1,1,0,1,1,0,1],
            [1,0,1,1,0,1,1,1,0,1,0,1,1,1,0,1,1,0,1],
            [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
            [1,0,1,1,0,1,0,1,1,1,1,1,0,1,0,1,1,0,1],
            [1,0,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,0,1],
            [1,1,1,1,0,1,1,1,2,1,2,1,1,1,0,1,1,1,1],
            [2,2,2,1,0,1,2,2,2,9,2,2,2,1,0,1,2,2,2],
            [1,1,1,1,0,1,2,1,1,2,1,1,2,1,0,1,1,1,1],
            [1,0,0,0,0,0,0,1,2,2,2,1,0,0,0,0,0,0,1],
            [1,0,1,1,0,1,1,1,0,1,0,1,1,1,0,1,1,0,1],
            [1,0,0,1,0,0,0,0,0,1,0,0,0,0,0,1,0,0,1],
            [1,1,0,1,0,1,0,1,1,1,1,1,0,1,0,1,0,1,1],
            [1,0,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,0,1],
            [1,3,1,1,1,1,1,1,0,1,0,1,1,1,1,1,1,3,1], // è§’è½å˜æˆ 3
            [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
            [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
        ];

        // ç”Ÿæˆ 4 å¥—å˜ä½“åœ°å›¾ï¼ˆæ¯ 5 å…³åˆ‡æ¢ä¸€æ¬¡ï¼‰
        const cloneMap = (map) => map.map(row => [...row]);
        const makeVariant = (base, changes = []) => {
            const m = cloneMap(base);
            changes.forEach(({x, y, val}) => {
                if (m[y] && typeof m[y][x] !== 'undefined') m[y][x] = val;
            });
            return m;
        };

        const MAP_VARIANTS = [
            RAW_MAP,
            // å˜ä½“2ï¼šä¸­å¤®å¢åŠ ç«‹æŸ±ã€å·¦å³ä¸­è·¯å¼€å£
            makeVariant(RAW_MAP, [
                {x:3, y:4, val:1}, {x:9, y:4, val:1}, {x:15, y:4, val:1},
                {x:3, y:13, val:1}, {x:9, y:13, val:1}, {x:15, y:13, val:1},
                {x:5, y:9, val:0}, {x:13, y:9, val:0}
            ]),
            // å˜ä½“3ï¼šé¬¼å±‹å‘¨å›´å¼€æ›´å¤§é€šé“
            makeVariant(RAW_MAP, [
                {x:3, y:7, val:0}, {x:15, y:7, val:0},
                {x:3, y:8, val:0}, {x:15, y:8, val:0},
                {x:3, y:9, val:0}, {x:15, y:9, val:0},
                {x:8, y:8, val:0}, {x:10, y:8, val:0}
            ]),
            // å˜ä½“4ï¼šå¢åŠ ä¸­æ®µéšœç¢
            makeVariant(RAW_MAP, [
                {x:5, y:4, val:1}, {x:13, y:4, val:1},
                {x:5, y:12, val:1}, {x:13, y:12, val:1},
                {x:1, y:5, val:1}, {x:17, y:5, val:1},
                {x:7, y:6, val:1}, {x:11, y:6, val:1}
            ])
        ];

        const getMapForLevel = (level) => {
            const idx = Math.min(MAP_VARIANTS.length - 1, Math.floor((level - 1) / 5));
            return cloneMap(MAP_VARIANTS[idx]);
        };

        class Particle {
            constructor(x, y, color, size) {
                this.x = x;
                this.y = y;
                this.color = color;
                this.vx = (Math.random() - 0.5) * 3;
                this.vy = (Math.random() - 0.5) * 3;
                this.life = 30;
                this.maxLife = 30;
                this.size = size || 4;
            }
            update() {
                this.x += this.vx;
                this.y += this.vy;
                this.life--;
                this.size *= 0.95; 
            }
            draw(ctx) {
                ctx.globalAlpha = this.life / this.maxLife;
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI*2);
                ctx.fill();
                ctx.globalAlpha = 1.0;
            }
        }

        class Entity {
            constructor(x, y, color) {
                this.x = x;
                this.y = y;
                this.startX = x;
                this.startY = y;
                this.color = color;
                this.dir = {x:0, y:0};
                this.nextDir = {x:0, y:0};
                this.radius = TILE_SIZE * 0.38; 
                this.speed = BASE_SPEED;
                this.tick = 0; 
            }

            canMove(dx, dy) {
                const nextX = Math.round(this.x + dx);
                const nextY = Math.round(this.y + dy);
                if (nextY < 0 || nextY >= game.map.length || nextX < 0 || nextX >= game.map[0].length) return false;
                return game.map[nextY][nextX] !== 1;
            }

            move() {
                this.tick++;
                this.x += this.dir.x * this.speed;
                this.y += this.dir.y * this.speed;

                const cx = Math.round(this.x);
                const cy = Math.round(this.y);
                const distToCenter = Math.abs(this.x - cx) + Math.abs(this.y - cy);

                if (distToCenter < 0.15) {
                    if (this.nextDir.x !== 0 || this.nextDir.y !== 0) {
                        if (this.canMove(this.nextDir.x, this.nextDir.y)) {
                            this.x = cx;
                            this.y = cy;
                            this.dir = {...this.nextDir};
                            this.nextDir = {x:0, y:0};
                        }
                    }
                    if (!this.canMove(this.dir.x, this.dir.y)) {
                        this.x = cx;
                        this.y = cy;
                        this.dir = {x:0, y:0};
                    }
                }
                if (this.x < -0.5) this.x = game.map[0].length - 0.5;
                if (this.x > game.map[0].length - 0.5) this.x = -0.5;
            }
        }

        class Pacman extends Entity {
            constructor(x, y) {
                super(x, y, '#fbbf24');
                this.scale = 1; 
            }

            update() {
                this.move();
                if (this.scale > 1) this.scale -= 0.05;
                else this.scale = 1;

                if (this.dir.x !== 0 || this.dir.y !== 0) {
                    if (this.tick % 6 === 0) {
                        game.particles.push(new Particle(
                            this.x * TILE_SIZE + TILE_SIZE/2,
                            this.y * TILE_SIZE + TILE_SIZE/2,
                            'rgba(251, 191, 36, 0.4)', 6
                        ));
                    }
                }
            }

            draw(ctx) {
                ctx.save();
                ctx.translate(this.x * TILE_SIZE + TILE_SIZE/2, this.y * TILE_SIZE + TILE_SIZE/2);
                ctx.scale(this.scale, this.scale);

                let rotation = 0;
                let flipY = 1;
                if (this.dir.x === -1) { rotation = Math.PI; flipY = -1; }
                else if (this.dir.x === 1) rotation = 0;
                else if (this.dir.y === -1) rotation = -Math.PI/2;
                else if (this.dir.y === 1) rotation = Math.PI/2;
                
                ctx.rotate(rotation);
                if (flipY === -1) ctx.scale(1, -1); 

                const wave = Math.sin(this.tick * 0.15); 
                const openSize = 0.02 + (wave + 1) * 0.12; 
                const openAngle = openSize * Math.PI;

                ctx.beginPath();
                ctx.arc(0, 0, this.radius, openAngle, 2 * Math.PI - openAngle);
                ctx.lineTo(0, 0);
                ctx.fillStyle = this.color;
                ctx.fill();
                ctx.closePath();

                const eyeX = 2; 
                const eyeY = -this.radius * 0.65; 
                
                ctx.fillStyle = '#1e293b';
                ctx.beginPath();
                ctx.arc(eyeX, eyeY, this.radius * 0.16, 0, Math.PI * 2);
                ctx.fill();

                ctx.fillStyle = '#fff';
                ctx.beginPath();
                ctx.arc(eyeX + 2, eyeY - 2, this.radius * 0.06, 0, Math.PI * 2);
                ctx.fill();

                ctx.restore();
            }
        }

        class Ghost extends Entity {
            constructor(x, y, color) {
                super(x, y, color);
                this.dir = {x: 1, y: 0}; 
                this.speed = BASE_SPEED * 0.6; 
                this.lastDecisionX = -1;
                this.lastDecisionY = -1;
                this.isScared = false; // å—æƒŠçŠ¶æ€
            }

            update() {
                this.tick++; 
                // å—æƒŠæ—¶é€Ÿåº¦å‡åŠ
                const currentSpeed = this.isScared ? this.speed * 0.5 : this.speed;
                
                const cx = Math.round(this.x);
                const cy = Math.round(this.y);
                const distToCenter = Math.abs(this.x - cx) + Math.abs(this.y - cy);
                const atNewCenter = distToCenter < 0.1 && (cx !== this.lastDecisionX || cy !== this.lastDecisionY);

                if (atNewCenter) {
                    this.x = cx;
                    this.y = cy;
                    this.lastDecisionX = cx;
                    this.lastDecisionY = cy;
                    
                    const possibleMoves = [];
                    const dirs = [{x:1, y:0}, {x:-1, y:0}, {x:0, y:1}, {x:0, y:-1}];
                    dirs.forEach(d => {
                        if (d.x === -this.dir.x && d.y === -this.dir.y) return; 
                        if (this.canMove(d.x, d.y)) possibleMoves.push(d);
                    });

                    if (possibleMoves.length > 0) {
                        // å—æƒŠæ¨¡å¼ï¼šå®Œå…¨éšæœºï¼ˆæˆ–è€…ç”šè‡³å¯ä»¥è®¾è®¡ä¸ºé€ƒç¦»ç©å®¶ï¼Œè¿™é‡Œç®€åŒ–ä¸ºéšæœºï¼‰
                        if (this.isScared) {
                             this.dir = possibleMoves[Math.floor(Math.random() * possibleMoves.length)];
                        } else {
                            // æ­£å¸¸æ¨¡å¼ï¼šæ™ºèƒ½è¿½è¸ª
                            const smartChance = Math.min((game.level - 1) * 0.1, 0.6);
                            const isSmart = Math.random() < smartChance;
                            if (isSmart && game.player) {
                                let bestMove = possibleMoves[0];
                                let minDistance = 99999;
                                possibleMoves.forEach(move => {
                                    const nextX = this.x + move.x;
                                    const nextY = this.y + move.y;
                                    const dist = Math.abs(nextX - game.player.x) + Math.abs(nextY - game.player.y);
                                    if (dist < minDistance) { minDistance = dist; bestMove = move; }
                                });
                                this.dir = bestMove;
                            } else {
                                this.dir = possibleMoves[Math.floor(Math.random() * possibleMoves.length)];
                            }
                        }
                    } else {
                        this.dir = {x: -this.dir.x, y: -this.dir.y}; 
                    }
                }
                this.x += this.dir.x * currentSpeed;
                this.y += this.dir.y * currentSpeed;
                if (this.x < -0.5) this.x = game.map[0].length - 0.5;
                if (this.x > game.map[0].length - 0.5) this.x = -0.5;
            }

            draw(ctx) {
                const cx = this.x * TILE_SIZE + TILE_SIZE/2;
                const hoverY = Math.sin(this.tick * 0.1) * 3;
                const cy = this.y * TILE_SIZE + TILE_SIZE/2 + hoverY;
                
                // å—æƒŠå˜æˆæ·±è“è‰²
                ctx.fillStyle = this.isScared ? '#3b82f6' : this.color;
                
                // é¬¼é­‚èº«ä½“
                ctx.beginPath();
                ctx.arc(cx, cy - 4, this.radius, Math.PI, 0);
                ctx.lineTo(cx + this.radius, cy + this.radius);
                
                // åº•éƒ¨æ³¢æµª
                const waveStep = this.radius * 2 / 3;
                for(let i=1; i<=3; i++) {
                    const cpX = cx + this.radius - waveStep * (i - 0.5);
                    const endX = cx + this.radius - waveStep * i;
                    const waveY = cy + this.radius + Math.sin(this.tick * 0.2 + i) * 2;
                    ctx.quadraticCurveTo(cpX, waveY, endX, cy + this.radius);
                }
                
                ctx.lineTo(cx - this.radius, cy - 4);
                ctx.fill();
                ctx.closePath();

                // çœ¼ç›
                if (this.isScared) {
                    ctx.fillStyle = '#fbbf24'; 
                    ctx.beginPath();
                    ctx.arc(cx - 4, cy - 4, 3, 0, Math.PI*2);
                    ctx.arc(cx + 4, cy - 4, 3, 0, Math.PI*2);
                    ctx.fill();
                    ctx.strokeStyle = '#fbbf24';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(cx - 6, cy + 6);
                    ctx.lineTo(cx - 3, cy + 2);
                    ctx.lineTo(cx, cy + 6);
                    ctx.lineTo(cx + 3, cy + 2);
                    ctx.lineTo(cx + 6, cy + 6);
                    ctx.stroke();
                } else {
                    ctx.fillStyle = '#fff';
                    ctx.beginPath();
                    ctx.ellipse(cx - 4, cy - 6, 4, 5, 0, 0, Math.PI*2);
                    ctx.ellipse(cx + 4, cy - 6, 4, 5, 0, 0, Math.PI*2);
                    ctx.fill();
                    
                    ctx.fillStyle = '#1e293b';
                    const lookX = this.dir.x * 1.5;
                    const lookY = this.dir.y * 1.5;
                    ctx.beginPath();
                    ctx.arc(cx - 4 + lookX, cy - 6 + lookY, 2, 0, Math.PI*2);
                    ctx.arc(cx + 4 + lookX, cy - 6 + lookY, 2, 0, Math.PI*2);
                    ctx.fill();
                }
            }

            resetGhost() {
                this.resetPos();
                this.dir = {x: 0, y: -1}; // é‡ç”Ÿåç«‹å³å‘ä¸Šå‡ºé—¨ï¼Œé˜²æ­¢å¡æ­»
                this.lastDecisionX = -1;
                this.lastDecisionY = -1;
                this.isScared = false;
            }
        }

        class AudioController {
            constructor() {
                this.ctx = new (window.AudioContext || window.webkitAudioContext)();
                this.enabled = true;
            }

            resume() {
                if (!this.enabled || !this.ctx) return;
                if (this.ctx.state === 'suspended') {
                    this.ctx.resume();
                }
            }

            playTone(freq, type, duration, startTime = 0) {
                if (!this.enabled) return;
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.type = type;
                osc.frequency.setValueAtTime(freq, this.ctx.currentTime + startTime);
                gain.gain.setValueAtTime(0.1, this.ctx.currentTime + startTime);
                gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + startTime + duration);
                osc.connect(gain);
                gain.connect(this.ctx.destination);
                osc.start(this.ctx.currentTime + startTime);
                osc.stop(this.ctx.currentTime + startTime + duration);
            }

            playWaka() {
                // ç»å…¸çš„åŒéŸ³ Waka
                this.playTone(200, 'triangle', 0.1);
                this.playTone(300, 'triangle', 0.1, 0.1);
            }

            playPower() {
                // å¤§åŠ›ä¸¸ï¼šé«˜é¢‘é¢¤éŸ³
                this.playTone(600, 'sine', 0.3);
                this.playTone(800, 'square', 0.3, 0.1);
            }

            playEatGhost() {
                // ä¸Šå‡ç¶éŸ³
                this.playTone(400, 'square', 0.1);
                this.playTone(600, 'square', 0.1, 0.1);
                this.playTone(800, 'square', 0.1, 0.2);
                this.playTone(1200, 'square', 0.2, 0.3);
            }

            playDie() {
                // ä¸‹å æ»‘éŸ³ (æ¨¡æ‹Ÿ)
                for (let i = 0; i < 10; i++) {
                    this.playTone(500 - i * 50, 'sawtooth', 0.1, i * 0.1);
                }
            }

            playWin() {
                // èƒœåˆ©æ—‹å¾‹
                [523, 659, 784, 1046, 784, 1046].forEach((freq, i) => {
                    this.playTone(freq, 'square', 0.2, i * 0.15);
                });
            }
        }

        class Game {
            constructor() {
                this.canvas = document.getElementById('gameCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.map = [];
                this.pellets = [];
                this.walls = [];
                this.particles = [];
                
                this.score = 0;
                this.level = 1;
                this.lives = 3; 
                this.maxLevelReached = Math.min(parseInt(localStorage.getItem('pacman_max_level')) || 1, RUN_MAX_LEVEL);
                this.highScore = parseInt(localStorage.getItem('pacman_high_score')) || 0;
                this.bestRunLevel = Math.min(parseInt(localStorage.getItem('pacman_best_run_level')) || 1, RUN_MAX_LEVEL);
                this.runHighest = 0;
                this.mode = 'FREE'; // FREE æˆ– RUN
                this.scaredTimer = 0;

                this.state = 'MENU'; 

                this.player = null;
                this.ghosts = [];
                this.loopId = null;
                this.audio = new AudioController(); // å®ä¾‹åŒ–éŸ³é¢‘æ§åˆ¶å™¨
                this.setupAudioUnlock(); // ç¡®ä¿é¦–æ¬¡äº¤äº’åéŸ³é¢‘å¯ç”¨

                this.initMap(getMapForLevel(1));
                this.setupInputs();
                this.updateHUD();
                
                this.showMenu(); // åˆå§‹æ˜¾ç¤ºèœå•
                this.loop(); // å¯åŠ¨å¾ªç¯ï¼ˆç”¨äºæ¸²æŸ“èƒŒæ™¯æˆ–èœå•åŠ¨ç”»ï¼Œè¿™é‡Œä¸»è¦ç”¨ loop é‡Œçš„ state åˆ¤æ–­ï¼‰
            }

            initMap(rawMap) {
                this.map = JSON.parse(JSON.stringify(rawMap));
                this.canvas.width = this.map[0].length * TILE_SIZE;
                this.canvas.height = this.map.length * TILE_SIZE;
            }

            // --- UI æ§åˆ¶ ---

            hideAllScreens() {
                document.querySelectorAll('.overlay').forEach(el => el.classList.add('hidden'));
                document.getElementById('pause-btn').style.display = 'none';
            }

            showMenu() {
                this.state = 'MENU';
                this.hideAllScreens();
                document.getElementById('screen-menu').classList.remove('hidden');
                document.getElementById('menu-max-level').innerText = this.maxLevelReached;
                document.getElementById('menu-best-run').innerText = this.bestRunLevel;
                // åœ¨èœå•ç•Œé¢ä¹Ÿå¯ä»¥ç”»ä¸€ä¸‹é™æ€èƒŒæ™¯
                this.draw();
            }

            showRules() {
                this.hideAllScreens();
                document.getElementById('screen-rules').classList.remove('hidden');
            }

            showLevelSelect() {
                this.hideAllScreens();
                const grid = document.getElementById('level-grid');
                grid.innerHTML = '';
                
                // ç”Ÿæˆ 1~20 å…³å¡æŒ‰é’®ï¼ˆæ™®é€šæ¨¡å¼ä¸é”å®šï¼‰
                for (let i = 1; i <= RUN_MAX_LEVEL; i++) {
                    const btn = document.createElement('button');
                    btn.className = 'level-btn';
                    btn.innerText = i;
                    btn.onclick = () => this.startNewGame(i, 'FREE');
                    grid.appendChild(btn);
                }
                document.getElementById('screen-levels').classList.remove('hidden');
            }

            // --- æ¸¸æˆæµç¨‹ ---

            startNewGame(startLevel = 1, mode = 'FREE') {
                this.mode = mode;
                this.level = startLevel;
                this.score = 0;
                this.lives = 3;
                this.runHighest = this.mode === 'RUN' ? startLevel : 0;
                this.updateHUD();
                this.startLevel(true);
            }

            startFullRun() {
                this.startNewGame(1, 'RUN');
            }

            restartGame() {
                // å…¨ç¨‹æ¨¡å¼ä»ç¬¬ 1 å…³é‡å¼€ï¼›æ™®é€šæ¨¡å¼é‡ç½®å½“å‰å…³å¡
                if (this.mode === 'RUN') {
                    this.startNewGame(1, 'RUN');
                } else {
                    this.restartLevel();
                }
            }

            restartLevel() {
                // å…³å¡é‡ç½®ï¼šæ™®é€šæ¨¡å¼ä¿ç•™åˆ†æ•°ã€å›æ»¡è¡€å¹¶é‡ç½®æœ¬å…³ï¼›å…¨ç¨‹æ¨¡å¼ç›´æ¥å›åˆ°ç¬¬1å…³é‡æ–°å¼€å§‹
                if (this.mode === 'RUN') {
                    this.startNewGame(1, 'RUN');
                    return;
                }
                this.score = 0; // æ™®é€šæ¨¡å¼é‡ç½®åˆ†æ•°
                this.lives = 3;
                this.updateHUD();
                this.startLevel(true); // é‡ç½®å½“å‰å…³å¡è±†å­å’Œå®ä½“
            }

            startLevel(respawnPellets) {
                if (respawnPellets) {
                    this.initMap(getMapForLevel(this.level));
                }
                this.resetEntities(respawnPellets);
                if (this.mode === 'RUN') {
                    this.runHighest = Math.max(this.runHighest || 0, this.level);
                    this.updateRunRecord();
                }
                this.state = 'READY';
                this.hideAllScreens();
                document.getElementById('pause-btn').style.display = 'flex';

                this.draw(); 
                const msg = document.getElementById('msg-float');
                msg.innerText = respawnPellets ? `ç¬¬ ${this.level} å…³` : "å‡†å¤‡"; 
                msg.style.display = 'block';
                
                setTimeout(() => { 
                    if (this.state !== 'READY') return; // é˜²æ­¢ä¸­é€”é€€å‡º
                    if (respawnPellets) msg.innerText = "å‡†å¤‡"; 
                }, 1000);
                
                setTimeout(() => { 
                    if (this.state !== 'READY') return;
                    msg.innerText = "å¼€å§‹ï¼"; 
                }, 2000);
                
                setTimeout(() => { 
                    if (this.state !== 'READY') return;
                    msg.style.display = 'none'; 
                    this.state = 'PLAYING';
                }, 2500);
            }

            pauseGame() {
                if (this.state === 'PLAYING') {
                    this.state = 'PAUSED';
                    document.getElementById('screen-paused').classList.remove('hidden');
                }
            }

            resumeGame() {
                if (this.state === 'PAUSED') {
                    this.state = 'PLAYING';
                    document.getElementById('screen-paused').classList.add('hidden');
                }
            }

            quitToMenu() {
                this.showMenu();
            }

            resetEntities(respawnPellets = false) {
                this.walls = [];
                this.ghosts = [];
                this.particles = [];
                
                if (respawnPellets) this.pellets = [];

                for (let y = 0; y < this.map.length; y++) {
                    for (let x = 0; x < this.map[y].length; x++) {
                        const type = this.map[y][x];
                        if (type === 1) this.walls.push({x, y});
                        
                        // æ™®é€šè±†å­ (0)
                        if (respawnPellets && type === 0) this.pellets.push({x, y, active: true, power: false});
                        // å¤§åŠ›ä¸¸ (3)
                        if (respawnPellets && type === 3) this.pellets.push({x, y, active: true, power: true});
                        
                        if (type === 9) {
                            const colors = ['#f87171', '#c084fc', '#38bdf8', '#fb923c', '#4ade80'];
                            let maxGhosts = 3;
                            if (this.level >= 3) maxGhosts = 4;
                            if (this.level >= 5) maxGhosts = 5;

                            while (this.ghosts.length < maxGhosts) {
                                this.ghosts.push(new Ghost(x, y, colors[this.ghosts.length % colors.length]));
                            }
                        }
                    }
                }

                this.player = new Pacman(9, 16);
                const speedMult = 1 + (this.level - 1) * 0.03; 
                this.player.speed = Math.min(BASE_SPEED * speedMult, 0.08);
                this.ghosts.forEach(g => g.speed = Math.min((BASE_SPEED * 0.6) * speedMult, 0.06));
            }

            update() {
                if (this.state === 'PLAYING') {
                    this.player.update();
                    this.ghosts.forEach(g => g.update());

                    // 1. æ›´æ–°å—æƒŠå€’è®¡æ—¶
                    if (this.scaredTimer > 0) {
                        this.scaredTimer--;
                        if (this.scaredTimer === 0) {
                            this.ghosts.forEach(g => g.isScared = false);
                        }
                    }

                    for(let i = this.particles.length - 1; i >= 0; i--) {
                        this.particles[i].update();
                        if(this.particles[i].life <= 0) this.particles.splice(i, 1);
                    }

                    // 2. åƒè±†æ£€æµ‹
                    const px = Math.round(this.player.x);
                    const py = Math.round(this.player.y);
                    const pIndex = this.pellets.findIndex(p => p.x === px && p.y === py && p.active);
                    
                    if (pIndex !== -1) {
                    const pellet = this.pellets[pIndex];
                    pellet.active = false;
                    this.score += 10;
                    this.player.scale = 1.3; 
                    
                    // --- åƒå¤§åŠ›ä¸¸é€»è¾‘ ---
                    if (pellet.power) {
                        this.scaredTimer = 600; // 10ç§’
                        this.ghosts.forEach(g => g.isScared = true);
                        this.score += 40;
                        this.audio.playPower();
                    } else {
                        this.audio.playWaka();
                    }
                    this.updateHUD();

                    // åƒè±†ç‰¹æ•ˆ
                    for(let k=0; k<4; k++) {
                        this.particles.push(new Particle(
                            px * TILE_SIZE + TILE_SIZE/2,
                                py * TILE_SIZE + TILE_SIZE/2,
                                pellet.power ? '#ff00ff' : '#fff', 
                                pellet.power ? 8 : 5
                            ));
                        }
                        if (this.pellets.every(p => !p.active)) {
                            this.levelComplete();
                        }
                    }

                    // 3. é¬¼é­‚ç¢°æ’æ£€æµ‹
                    for (let g of this.ghosts) {
                        const dist = Math.hypot(this.player.x - g.x, this.player.y - g.y);
                        if (dist < 0.6) {
                            // --- åæ€é€»è¾‘ ---
                            if (g.isScared) {
                                // åƒæ‰é¬¼é­‚ï¼
                                // ç›´æ¥é‡ç½®çŠ¶æ€ï¼Œä¸è°ƒç”¨æ–¹æ³•ä»¥é˜²ä¸‡ä¸€
                                g.x = g.startX;
                                g.y = g.startY;
                                g.dir = {x: 0, y: -1}; // å‘ä¸Šå‡ºé—¨
                                g.nextDir = {x:0, y:0};
                                g.lastDecisionX = -1;
                                g.lastDecisionY = -1;
                                g.isScared = false; 
                                
                                this.score += 200;
                                this.updateHUD();
                                
                                this.audio.playEatGhost();
                                
                                // åƒé¬¼ç‰¹æ•ˆ (è“è‰²çˆ†ç‚¸)
                                for(let i=0; i<20; i++) {
                                    this.particles.push(new Particle(
                                        this.player.x * TILE_SIZE + TILE_SIZE/2,
                                        this.player.y * TILE_SIZE + TILE_SIZE/2,
                                        '#3b82f6', 6
                                    ));
                                }
                            } else {
                                // è¢«é¬¼é­‚åƒæ‰
                                this.deathSequence();
                                return;
                            }
                        }
                    }
                } else if (this.state === 'DYING') {
                    for(let i = this.particles.length - 1; i >= 0; i--) {
                        this.particles[i].update();
                        if(this.particles[i].life <= 0) this.particles.splice(i, 1);
                    }
                }
            }

            deathSequence() {
                this.state = 'DYING';
                this.lives--;
                this.updateHUD();
                this.audio.playDie();

                for(let i=0; i<30; i++) {
                    this.particles.push(new Particle(
                        this.player.x * TILE_SIZE + TILE_SIZE/2,
                        this.player.y * TILE_SIZE + TILE_SIZE/2,
                        '#fbbf24', 8
                    ));
                }
                
                setTimeout(() => {
                    if (this.state !== 'DYING') return; // é˜²æ­¢ä¸­é€”é€€å‡º
                    if (this.lives > 0) {
                        this.startLevel(false); 
                    } else {
                        this.gameOver();
                    }
                }, 1500);
            }

            levelComplete() {
                this.state = 'LEVEL_TRANSITION';
                this.pellets = []; 
                this.audio.playWin();
                const nextLevel = Math.min(this.level + 1, RUN_MAX_LEVEL);
                // è§£é”æ–°å…³å¡
                if (nextLevel > this.maxLevelReached) {
                    this.maxLevelReached = nextLevel;
                    localStorage.setItem('pacman_max_level', this.maxLevelReached);
                }

                if (this.mode === 'RUN') {
                    this.runHighest = Math.max(this.runHighest, this.level);
                    this.updateRunRecord();
                    if (this.level >= RUN_MAX_LEVEL) {
                        this.runComplete();
                        return;
                    }
                }
                document.getElementById('next-level-num').innerText = nextLevel;
                document.getElementById('screen-levelup').classList.remove('hidden');
                
                setTimeout(() => {
                    if (this.state !== 'LEVEL_TRANSITION') return;
                    document.getElementById('screen-levelup').classList.add('hidden');
                    this.level = nextLevel;
                    this.startLevel(true);
                }, 3000);
            }

            runComplete() {
                this.state = 'RUN_COMPLETE';
                this.updateRunRecord();
                this.updateHUD();
                document.getElementById('runcomplete-level').innerText = this.runHighest;
                document.getElementById('runcomplete-score').innerText = this.score;
                document.getElementById('runcomplete-best').innerText = this.bestRunLevel;
                document.getElementById('screen-levelup').classList.add('hidden');
                document.getElementById('screen-runcomplete').classList.remove('hidden');
                document.getElementById('pause-btn').style.display = 'none';
            }

            gameOver() {
                this.state = 'GAMEOVER';
                this.updateRunRecord();
                this.updateHUD();
                document.getElementById('end-score').innerText = this.score;
                const runBestRow = document.getElementById('end-run-best');
                if (this.mode === 'RUN') {
                    document.getElementById('end-run-best-value').innerText = this.bestRunLevel;
                    runBestRow.classList.remove('hidden');
                } else {
                    runBestRow.classList.add('hidden');
                }
                document.getElementById('screen-gameover').classList.remove('hidden');
                document.getElementById('pause-btn').style.display = 'none';
            }

            draw() {
                // å¦‚æœåœ¨èœå•çŠ¶æ€ï¼Œä¹Ÿå¯ä»¥ç”»èƒŒæ™¯
                const theme = LEVEL_THEMES[(this.level - 1) % LEVEL_THEMES.length];
                this.ctx.fillStyle = theme.bg;
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

                // Draw Walls 
                this.ctx.fillStyle = theme.wall;
                this.walls.forEach(w => {
                    const cx = w.x * TILE_SIZE;
                    const cy = w.y * TILE_SIZE;
                    const size = TILE_SIZE;
                    const pad = 0; 
                    this.ctx.beginPath();
                    this.ctx.roundRect(cx + pad, cy + pad, size - pad*2, size - pad*2, 8);
                    this.ctx.fill();
                });

                // Draw Pellets
                this.pellets.forEach(p => {
                    if (p.active) {
                        this.ctx.beginPath();
                        if (p.power) {
                            // å¤§åŠ›ä¸¸ï¼šé—ªçƒå¤§çƒ
                            const pulse = Math.sin(this.player ? this.player.tick * 0.2 : Date.now() * 0.01) * 2;
                            this.ctx.fillStyle = '#ff00ff'; // éœ“è™¹ç²‰
                            this.ctx.arc(p.x * TILE_SIZE + TILE_SIZE/2, p.y * TILE_SIZE + TILE_SIZE/2, 7 + pulse, 0, Math.PI*2);
                            this.ctx.shadowBlur = 15;
                            this.ctx.shadowColor = '#ff00ff';
                            this.ctx.fill();
                            this.ctx.shadowBlur = 0;
                        } else {
                            // æ™®é€šè±†å­
                            this.ctx.fillStyle = '#fbbf24';
                            this.ctx.arc(p.x * TILE_SIZE + TILE_SIZE/2, p.y * TILE_SIZE + TILE_SIZE/2, 5, 0, Math.PI*2);
                            this.ctx.fill();
                        }
                    }
                });

                this.particles.forEach(p => p.draw(this.ctx));

                if (this.state !== 'MENU' && this.state !== 'GAMEOVER_SCREEN' && this.player) {
                    if (this.state !== 'DYING') this.player.draw(this.ctx);
                    this.ghosts.forEach(g => g.draw(this.ctx));
                }
            }

            loop() {
                // ä¸»å¾ªç¯å§‹ç»ˆè¿è¡Œï¼Œæ ¹æ®çŠ¶æ€å†³å®š update
                if (this.state === 'PLAYING' || this.state === 'DYING') {
                    this.update();
                }
                this.draw(); // å§‹ç»ˆç»˜åˆ¶ï¼Œä¿æŒç”»é¢ä¸æ¶ˆå¤±ï¼ˆæš‚åœæ—¶ä¹Ÿèƒ½çœ‹åˆ°å®šæ ¼ç”»é¢ï¼‰
                this.loopId = requestAnimationFrame(() => this.loop());
            }

            updateHighScore() {
                if (this.score > this.highScore) {
                    this.highScore = this.score;
                    localStorage.setItem('pacman_high_score', this.highScore);
                }
            }

            updateRunRecord() {
                if (this.mode !== 'RUN') return;
                if (this.runHighest > this.bestRunLevel) {
                    this.bestRunLevel = this.runHighest;
                    localStorage.setItem('pacman_best_run_level', this.bestRunLevel);
                    const menuRun = document.getElementById('menu-best-run');
                    if (menuRun) menuRun.innerText = this.bestRunLevel;
                }
            }

            updateHUD() {
                this.updateHighScore();
                document.getElementById('ui-score').innerText = this.score;
                document.getElementById('ui-level').innerText = this.level;
                const hearts = 'â¤ï¸'.repeat(Math.max(0, this.lives));
                document.getElementById('ui-lives').innerText = hearts;
                document.getElementById('ui-high-score').innerText = `æœ€é«˜ ${this.highScore}`;
                const runBadge = document.getElementById('ui-run-mode');
                if (this.mode === 'RUN') {
                    runBadge.innerText = `å…¨ç¨‹ 1â†’${RUN_MAX_LEVEL}`;
                    runBadge.classList.remove('hidden');
                } else {
                    runBadge.classList.add('hidden');
                }
            }

            setupAudioUnlock() {
                const unlock = () => {
                    this.audio.resume();
                    ['click', 'keydown', 'touchstart'].forEach(evt => document.removeEventListener(evt, unlock));
                };
                ['click', 'keydown', 'touchstart'].forEach(evt => {
                    document.addEventListener(evt, unlock, { once: true });
                });
            }

            setupInputs() {
                document.addEventListener('keydown', (e) => {
                    // åªæœ‰æ¸¸æˆä¸­æ‰å“åº”ç§»åŠ¨ï¼Œæš‚åœæˆ–èœå•ä¸å“åº”
                    if (this.state !== 'PLAYING') return;
                    if(['ArrowUp','ArrowDown','ArrowLeft','ArrowRight'].indexOf(e.code) > -1) e.preventDefault();

                    switch(e.key) {
                        case 'ArrowUp': this.player.nextDir = {x: 0, y: -1}; break;
                        case 'ArrowDown': this.player.nextDir = {x: 0, y: 1}; break;
                        case 'ArrowLeft': this.player.nextDir = {x: -1, y: 0}; break;
                        case 'ArrowRight': this.player.nextDir = {x: 1, y: 0}; break;
                    }
                });
            }
        }

        const game = new Game();

    </script>
</body>
</html>
        }
        button.secondary:hover {
            background: #cbd5e1;
        }

        /* å…³å¡é€‰æ‹©ç½‘æ ¼ */
        #level-grid {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 10px;
            margin-bottom: 30px;
        }
        .level-btn {
            width: 50px;
            height: 50px;
            padding: 0;
            font-size: 18px;
            background: #e2e8f0;
            color: #64748b;
            box-shadow: none;
        }
        .level-btn.locked {
            background: #f1f5f9;
            color: #cbd5e1;
            cursor: not-allowed;
        }
        .level-btn:not(.locked):hover {
            background: #3b82f6;
            color: white;
        }

        /* è§„åˆ™è¯´æ˜ */
        .rules-list {
            text-align: left;
            font-size: 14px;
            color: #475569;
            margin-bottom: 30px;
            line-height: 2;
            background: #f8fafc;
            padding: 20px;
            border-radius: 12px;
            width: 100%;
        }
        .rules-list i {
            width: 20px;
            text-align: center;
            margin-right: 8px;
        }

        #msg-float {
            position: absolute;
            top: 55%; /* ç¨å¾®é ä¸‹ï¼Œé¿å¼€ä¸­å¿ƒ */
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 60px;
            font-weight: 800;
            color: #fff;
            text-shadow: 0 4px 10px rgba(0,0,0,0.2);
            display: none;
            pointer-events: none;
            z-index: 20;
        }

        .hidden { display: none !important; }
    </style>
</head>
<body>

    <div id="game-wrapper">
        <div id="hud">
            <div class="stat-card" style="align-items: flex-start; width: 120px;">
                <div class="stat-label">ç”Ÿå‘½</div>
                <div id="ui-lives" class="stat-value" style="color: #ef4444; font-size: 20px;">â¤ï¸â¤ï¸â¤ï¸</div>
            </div>
            <div class="stat-card">
                <div class="stat-label">å¾—åˆ†</div>
                <div id="ui-score" class="stat-value" style="color: #3b82f6;">0</div>
                <div id="ui-high-score" class="stat-subvalue">æœ€é«˜ 0</div>
            </div>
            <!-- å³ä¾§ç»„åˆï¼šå…³å¡ + æš‚åœ -->
            <div style="display: flex; align-items: center; width: 120px; justify-content: flex-end;">
                <div class="stat-card" style="align-items: flex-end; margin-right: 0;">
                    <div class="stat-label">å…³å¡</div>
                    <div id="ui-level" class="stat-value">1</div>
                    <div id="ui-run-mode" class="stat-subvalue hidden">å…¨ç¨‹ 1â†’20</div>
                </div>
                <button id="pause-btn" onclick="game.pauseGame()">
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor"><rect x="6" y="4" width="4" height="16"/><rect x="14" y="4" width="4" height="16"/></svg>
                </button>
            </div>
        </div>

        <div style="position: relative;">
            <canvas id="gameCanvas" width="665" height="630"></canvas>
            <div id="msg-float">å‡†å¤‡</div>
        </div>

        <!-- 1. ä¸»èœå• -->
        <div id="screen-menu" class="overlay">
            <div class="menu-decoration">
                <div class="floating-ghost" style="background: #ef4444; animation-delay: 0s;"></div>
                <div class="css-pacman" style="margin: 0 20px;"></div>
                <div class="floating-ghost" style="background: #3b82f6; animation-delay: 1s;"></div>
            </div>
            <div class="title" style="background: none; -webkit-text-fill-color: initial;">
                <div class="brand-title"><span class="brand-chomp">åƒ</span><span class="brand-chomp">è±†</span><span class="brand-chomp">äºº</span></div>
                <div class="brand-tagline">PAC-MAN</div>
            </div>
            
            <div class="btn-group">
                <button onclick="game.startFullRun()">
                    <svg width="18" height="18" viewBox="0 0 24 24" fill="currentColor"><path d="M5 3v18l15-9z"/></svg> å…¨ç¨‹æŒ‘æˆ˜
                </button>
                <button onclick="game.showLevelSelect()">
                    <svg width="18" height="18" viewBox="0 0 24 24" fill="currentColor"><path d="M8 5v14l11-7z"/></svg> å¼€å§‹æ¸¸æˆ
                </button>
                <button class="secondary" onclick="game.showRules()">
                    <svg width="18" height="18" viewBox="0 0 24 24" fill="currentColor"><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm1 15h-2v-6h2v6zm0-8h-2V7h2v2z"/></svg> ç©æ³•è¯´æ˜
                </button>
            </div>
            <div style="margin-top: 30px; font-size: 12px; color: #94a3b8;">
                æœ€é«˜è§£é”å…³å¡ï¼š<span id="menu-max-level">1</span>
                <br/>å…¨ç¨‹æœ€ä½³è¿›åº¦ï¼š<span id="menu-best-run">1</span>
            </div>
        </div>

        <!-- 2. å…³å¡é€‰æ‹© -->
        <div id="screen-levels" class="overlay hidden">
            <div class="title" style="font-size: 32px;">é€‰æ‹©å…³å¡</div>
            <div class="subtitle">é€‰æ‹©ä»»æ„å·²è§£é”çš„å…³å¡å¼€å§‹æ¸¸æˆã€‚</div>
            <div id="level-grid">
                <!-- JSç”Ÿæˆ -->
            </div>
            <button class="secondary" style="width: auto; padding: 10px 30px;" onclick="game.showMenu()">è¿”å›</button>
        </div>

        <!-- 3. è§„åˆ™è¯´æ˜ -->
        <div id="screen-rules" class="overlay hidden">
            <div class="title" style="font-size: 32px;">ç©æ³•è¯´æ˜</div>
            <div class="rules-list">
                <div><span style="margin-right: 8px;">âŒ¨ï¸</span> ä½¿ç”¨æ–¹å‘é”®ç§»åŠ¨</div>
                <div><span style="margin-right: 8px;">ğŸŸ¡</span> åƒå®Œæ‰€æœ‰è±†å­å³å¯è¿‡å…³</div>
                <div><span style="margin-right: 8px;">ğŸŸ£</span> åƒå¤§åŠ›ä¸¸å¯ä»¥ååƒå¹½çµï¼</div>
                <div><span style="margin-right: 8px;">ğŸ‘»</span> è¿œç¦»å¹½çµï¼ˆç¢°åˆ°ä¼šå¤±å» 1 æ¡å‘½ï¼‰</div>
                <div><span style="margin-right: 8px;">â¤ï¸</span> æ¯å±€æœ‰ 3 æ¡å‘½</div>
                <div><span style="margin-right: 8px;">âš¡</span> æ¯ä¸€å…³é€Ÿåº¦éƒ½ä¼šæ›´å¿«</div>
                <div><span style="margin-right: 8px;">ğŸ</span> è¯•è¯•å…¨ç¨‹æŒ‘æˆ˜ï¼Œä»ç¬¬ 1 å…³è·‘åˆ°ç¬¬ 20 å…³ï¼Œå†²å‡»ä½ çš„æœ€ä½³çºªå½•ï¼</div>
            </div>
            <button onclick="game.showMenu()">çŸ¥é“äº†ï¼</button>
        </div>

        <!-- 4. æš‚åœèœå• -->
        <div id="screen-paused" class="overlay glass hidden">
            <div class="title" style="font-size: 40px;">å·²æš‚åœ</div>
            <div class="btn-group">
                <button onclick="game.resumeGame()">
                    <svg width="18" height="18" viewBox="0 0 24 24" fill="currentColor"><path d="M8 5v14l11-7z"/></svg> ç»§ç»­æ¸¸æˆ
                </button>
                <button class="secondary" onclick="game.restartLevel()">
                    <svg width="18" height="18" viewBox="0 0 24 24" fill="currentColor"><path d="M17.65 6.35C16.2 4.9 14.21 4 12 4c-4.42 0-7.99 3.58-7.99 8s3.57 8 7.99 8c3.73 0 6.84-2.55 7.73-6h-2.08c-.82 2.33-3.04 4-5.65 4-3.31 0-6-2.69-6-6s2.69-6 6-6c1.66 0 3.14.69 4.22 1.78L13 11h7V4l-2.35 2.35z"/></svg> é‡ç©æœ¬å…³
                </button>
                <button class="secondary" onclick="game.quitToMenu()">
                    <svg width="18" height="18" viewBox="0 0 24 24" fill="currentColor"><path d="M10 20v-6h4v6h5v-8h3L12 3 2 12h3v8z"/></svg> è¿”å›èœå•
                </button>
            </div>
        </div>

        <!-- 5. æ¸¸æˆç»“æŸ -->
        <div id="screen-gameover" class="overlay glass hidden">
            <div class="title" style="color: #ef4444; -webkit-text-fill-color: #ef4444; background: none;">æ¸¸æˆç»“æŸ</div>
            <div class="subtitle">æœ€ç»ˆå¾—åˆ†ï¼š<span id="end-score" style="font-weight: bold; color: #1e293b; font-size: 24px;">0</span></div>
            <div id="end-run-best" class="subtitle hidden">å…¨ç¨‹æœ€ä½³è¿›åº¦ï¼š<span id="end-run-best-value" style="font-weight: bold; color: #1e293b;">1</span></div>
            <div class="btn-group">
                <button onclick="game.restartGame()">
                    <svg width="18" height="18" viewBox="0 0 24 24" fill="currentColor"><path d="M17.65 6.35C16.2 4.9 14.21 4 12 4c-4.42 0-7.99 3.58-7.99 8s3.57 8 7.99 8c3.73 0 6.84-2.55 7.73-6h-2.08c-.82 2.33-3.04 4-5.65 4-3.31 0-6-2.69-6-6s2.69-6 6-6c1.66 0 3.14.69 4.22 1.78L13 11h7V4l-2.35 2.35z"/></svg> å†è¯•ä¸€æ¬¡
                </button>
                <button class="secondary" onclick="game.quitToMenu()">
                    <svg width="18" height="18" viewBox="0 0 24 24" fill="currentColor"><path d="M10 20v-6h4v6h5v-8h3L12 3 2 12h3v8z"/></svg> è¿”å›èœå•
                </button>
            </div>
        </div>

        <!-- 5.5 å…¨ç¨‹æ¨¡å¼å®Œæˆ -->
        <div id="screen-runcomplete" class="overlay glass hidden">
            <div class="title" style="color: #10b981; -webkit-text-fill-color: #10b981; background: none;">å…¨ç¨‹é€šå…³</div>
            <div class="subtitle">æœ¬æ¬¡åˆ°è¾¾ç¬¬ <span id="runcomplete-level">20</span> å…³ï¼Œå¾—åˆ† <span id="runcomplete-score" style="font-weight: bold; color: #1e293b;">0</span></div>
            <div class="subtitle">å…¨ç¨‹æœ€ä½³è¿›åº¦ï¼š<span id="runcomplete-best" style="font-weight: bold; color: #1e293b;">1</span></div>
            <div class="btn-group">
                <button onclick="game.restartGame()">
                    <svg width="18" height="18" viewBox="0 0 24 24" fill="currentColor"><path d="M17.65 6.35C16.2 4.9 14.21 4 12 4c-4.42 0-7.99 3.58-7.99 8s3.57 8 7.99 8c3.73 0 6.84-2.55 7.73-6h-2.08c-.82 2.33-3.04 4-5.65 4-3.31 0-6-2.69-6-6s2.69-6 6-6c1.66 0 3.14.69 4.22 1.78L13 11h7V4l-2.35 2.35z"/></svg> å†è·‘ä¸€é
                </button>
                <button class="secondary" onclick="game.quitToMenu()">
                    <svg width="18" height="18" viewBox="0 0 24 24" fill="currentColor"><path d="M10 20v-6h4v6h5v-8h3L12 3 2 12h3v8z"/></svg> è¿”å›èœå•
                </button>
            </div>
        </div>

        <!-- 6. å…³å¡å®Œæˆ -->
        <div id="screen-levelup" class="overlay glass hidden">
            <div class="title" style="color: #10b981; -webkit-text-fill-color: #10b981; background: none;">å…³å¡å®Œæˆï¼</div>
            <div class="subtitle">ä¸‹ä¸€å…³ï¼š<span id="next-level-num">2</span></div>
        </div>
    </div>

    <script>
        const TILE_SIZE = 35; 
        const BASE_SPEED = 0.03; 
        const RUN_MAX_LEVEL = 20; // å…¨ç¨‹æ¨¡å¼çš„ç»ˆç‚¹å…³å¡
        
        const LEVEL_THEMES = [
            { wall: '#475569', bg: '#1e293b' }, 
            { wall: '#7c2d12', bg: '#451a03' }, 
            { wall: '#10b981', bg: '#022c22' }, 
            { wall: '#4c1d95', bg: '#2e1065' }, 
            { wall: '#831843', bg: '#500724' }  
        ];

        const RAW_MAP = [
            [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
            [1,3,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,3,1], // è§’è½å˜æˆ 3 (å¤§åŠ›ä¸¸)
            [1,0,1,1,0,1,1,1,0,1,0,1,1,1,0,1,1,0,1],
            [1,0,1,1,0,1,1,1,0,1,0,1,1,1,0,1,1,0,1],
            [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
            [1,0,1,1,0,1,0,1,1,1,1,1,0,1,0,1,1,0,1],
            [1,0,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,0,1],
            [1,1,1,1,0,1,1,1,2,1,2,1,1,1,0,1,1,1,1],
            [2,2,2,1,0,1,2,2,2,9,2,2,2,1,0,1,2,2,2],
            [1,1,1,1,0,1,2,1,1,2,1,1,2,1,0,1,1,1,1],
            [1,0,0,0,0,0,0,1,2,2,2,1,0,0,0,0,0,0,1],
            [1,0,1,1,0,1,1,1,0,1,0,1,1,1,0,1,1,0,1],
            [1,0,0,1,0,0,0,0,0,1,0,0,0,0,0,1,0,0,1],
            [1,1,0,1,0,1,0,1,1,1,1,1,0,1,0,1,0,1,1],
            [1,0,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,0,1],
            [1,3,1,1,1,1,1,1,0,1,0,1,1,1,1,1,1,3,1], // è§’è½å˜æˆ 3
            [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
            [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
        ];

        // ç”Ÿæˆ 4 å¥—å˜ä½“åœ°å›¾ï¼ˆæ¯ 5 å…³åˆ‡æ¢ä¸€æ¬¡ï¼‰
        const cloneMap = (map) => map.map(row => [...row]);
        const makeVariant = (base, changes = []) => {
            const m = cloneMap(base);
            changes.forEach(({x, y, val}) => {
                if (m[y] && typeof m[y][x] !== 'undefined') m[y][x] = val;
            });
            return m;
        };

        const MAP_VARIANTS = [
            RAW_MAP,
            // å˜ä½“2ï¼šä¸­å¤®å¢åŠ ç«‹æŸ±ã€å·¦å³ä¸­è·¯å¼€å£
            makeVariant(RAW_MAP, [
                {x:3, y:4, val:1}, {x:9, y:4, val:1}, {x:15, y:4, val:1},
                {x:3, y:13, val:1}, {x:9, y:13, val:1}, {x:15, y:13, val:1},
                {x:5, y:9, val:0}, {x:13, y:9, val:0}
            ]),
            // å˜ä½“3ï¼šé¬¼å±‹å‘¨å›´å¼€æ›´å¤§é€šé“
            makeVariant(RAW_MAP, [
                {x:3, y:7, val:0}, {x:15, y:7, val:0},
                {x:3, y:8, val:0}, {x:15, y:8, val:0},
                {x:3, y:9, val:0}, {x:15, y:9, val:0},
                {x:8, y:8, val:0}, {x:10, y:8, val:0}
            ]),
            // å˜ä½“4ï¼šå¢åŠ ä¸­æ®µéšœç¢
            makeVariant(RAW_MAP, [
                {x:5, y:4, val:1}, {x:13, y:4, val:1},
                {x:5, y:12, val:1}, {x:13, y:12, val:1},
                {x:1, y:5, val:1}, {x:17, y:5, val:1},
                {x:7, y:6, val:1}, {x:11, y:6, val:1}
            ])
        ];

        const getMapForLevel = (level) => {
            const idx = Math.min(MAP_VARIANTS.length - 1, Math.floor((level - 1) / 5));
            return cloneMap(MAP_VARIANTS[idx]);
        };

        class Particle {
            constructor(x, y, color, size) {
                this.x = x;
                this.y = y;
                this.color = color;
                this.vx = (Math.random() - 0.5) * 3;
                this.vy = (Math.random() - 0.5) * 3;
                this.life = 30;
                this.maxLife = 30;
                this.size = size || 4;
            }
            update() {
                this.x += this.vx;
                this.y += this.vy;
                this.life--;
                this.size *= 0.95; 
            }
            draw(ctx) {
                ctx.globalAlpha = this.life / this.maxLife;
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI*2);
                ctx.fill();
                ctx.globalAlpha = 1.0;
            }
        }

        class Entity {
            constructor(x, y, color) {
                this.x = x;
                this.y = y;
                this.startX = x;
                this.startY = y;
                this.color = color;
                this.dir = {x:0, y:0};
                this.nextDir = {x:0, y:0};
                this.radius = TILE_SIZE * 0.38; 
                this.speed = BASE_SPEED;
                this.tick = 0; 
            }

            canMove(dx, dy) {
                const nextX = Math.round(this.x + dx);
                const nextY = Math.round(this.y + dy);
                if (nextY < 0 || nextY >= game.map.length || nextX < 0 || nextX >= game.map[0].length) return false;
                return game.map[nextY][nextX] !== 1;
            }

            move() {
                this.tick++;
                this.x += this.dir.x * this.speed;
                this.y += this.dir.y * this.speed;

                const cx = Math.round(this.x);
                const cy = Math.round(this.y);
                const distToCenter = Math.abs(this.x - cx) + Math.abs(this.y - cy);

                if (distToCenter < 0.15) {
                    if (this.nextDir.x !== 0 || this.nextDir.y !== 0) {
                        if (this.canMove(this.nextDir.x, this.nextDir.y)) {
                            this.x = cx;
                            this.y = cy;
                            this.dir = {...this.nextDir};
                            this.nextDir = {x:0, y:0};
                        }
                    }
                    if (!this.canMove(this.dir.x, this.dir.y)) {
                        this.x = cx;
                        this.y = cy;
                        this.dir = {x:0, y:0};
                    }
                }
                if (this.x < -0.5) this.x = game.map[0].length - 0.5;
                if (this.x > game.map[0].length - 0.5) this.x = -0.5;
            }
        }

        class Pacman extends Entity {
            constructor(x, y) {
                super(x, y, '#fbbf24');
                this.scale = 1; 
            }

            update() {
                this.move();
                if (this.scale > 1) this.scale -= 0.05;
                else this.scale = 1;

                if (this.dir.x !== 0 || this.dir.y !== 0) {
                    if (this.tick % 6 === 0) {
                        game.particles.push(new Particle(
                            this.x * TILE_SIZE + TILE_SIZE/2,
                            this.y * TILE_SIZE + TILE_SIZE/2,
                            'rgba(251, 191, 36, 0.4)', 6
                        ));
                    }
                }
            }

            draw(ctx) {
                ctx.save();
                ctx.translate(this.x * TILE_SIZE + TILE_SIZE/2, this.y * TILE_SIZE + TILE_SIZE/2);
                ctx.scale(this.scale, this.scale);

                let rotation = 0;
                let flipY = 1;
                if (this.dir.x === -1) { rotation = Math.PI; flipY = -1; }
                else if (this.dir.x === 1) rotation = 0;
                else if (this.dir.y === -1) rotation = -Math.PI/2;
                else if (this.dir.y === 1) rotation = Math.PI/2;
                
                ctx.rotate(rotation);
                if (flipY === -1) ctx.scale(1, -1); 

                const wave = Math.sin(this.tick * 0.15); 
                const openSize = 0.02 + (wave + 1) * 0.12; 
                const openAngle = openSize * Math.PI;

                ctx.beginPath();
                ctx.arc(0, 0, this.radius, openAngle, 2 * Math.PI - openAngle);
                ctx.lineTo(0, 0);
                ctx.fillStyle = this.color;
                ctx.fill();
                ctx.closePath();

                const eyeX = 2; 
                const eyeY = -this.radius * 0.65; 
                
                ctx.fillStyle = '#1e293b';
                ctx.beginPath();
                ctx.arc(eyeX, eyeY, this.radius * 0.16, 0, Math.PI * 2);
                ctx.fill();

                ctx.fillStyle = '#fff';
                ctx.beginPath();
                ctx.arc(eyeX + 2, eyeY - 2, this.radius * 0.06, 0, Math.PI * 2);
                ctx.fill();

                ctx.restore();
            }
        }

        class Ghost extends Entity {
            constructor(x, y, color) {
                super(x, y, color);
                this.dir = {x: 1, y: 0}; 
                this.speed = BASE_SPEED * 0.6; 
                this.lastDecisionX = -1;
                this.lastDecisionY = -1;
                this.isScared = false; // å—æƒŠçŠ¶æ€
            }

            update() {
                this.tick++; 
                // å—æƒŠæ—¶é€Ÿåº¦å‡åŠ
                const currentSpeed = this.isScared ? this.speed * 0.5 : this.speed;
                
                const cx = Math.round(this.x);
                const cy = Math.round(this.y);
                const distToCenter = Math.abs(this.x - cx) + Math.abs(this.y - cy);
                const atNewCenter = distToCenter < 0.1 && (cx !== this.lastDecisionX || cy !== this.lastDecisionY);

                if (atNewCenter) {
                    this.x = cx;
                    this.y = cy;
                    this.lastDecisionX = cx;
                    this.lastDecisionY = cy;
                    
                    const possibleMoves = [];
                    const dirs = [{x:1, y:0}, {x:-1, y:0}, {x:0, y:1}, {x:0, y:-1}];
                    dirs.forEach(d => {
                        if (d.x === -this.dir.x && d.y === -this.dir.y) return; 
                        if (this.canMove(d.x, d.y)) possibleMoves.push(d);
                    });

                    if (possibleMoves.length > 0) {
                        // å—æƒŠæ¨¡å¼ï¼šå®Œå…¨éšæœºï¼ˆæˆ–è€…ç”šè‡³å¯ä»¥è®¾è®¡ä¸ºé€ƒç¦»ç©å®¶ï¼Œè¿™é‡Œç®€åŒ–ä¸ºéšæœºï¼‰
                        if (this.isScared) {
                             this.dir = possibleMoves[Math.floor(Math.random() * possibleMoves.length)];
                        } else {
                            // æ­£å¸¸æ¨¡å¼ï¼šæ™ºèƒ½è¿½è¸ª
                            const smartChance = Math.min((game.level - 1) * 0.1, 0.6);
                            const isSmart = Math.random() < smartChance;
                            if (isSmart && game.player) {
                                let bestMove = possibleMoves[0];
                                let minDistance = 99999;
                                possibleMoves.forEach(move => {
                                    const nextX = this.x + move.x;
                                    const nextY = this.y + move.y;
                                    const dist = Math.abs(nextX - game.player.x) + Math.abs(nextY - game.player.y);
                                    if (dist < minDistance) { minDistance = dist; bestMove = move; }
                                });
                                this.dir = bestMove;
                            } else {
                                this.dir = possibleMoves[Math.floor(Math.random() * possibleMoves.length)];
                            }
                        }
                    } else {
                        this.dir = {x: -this.dir.x, y: -this.dir.y}; 
                    }
                }
                this.x += this.dir.x * currentSpeed;
                this.y += this.dir.y * currentSpeed;
                if (this.x < -0.5) this.x = game.map[0].length - 0.5;
                if (this.x > game.map[0].length - 0.5) this.x = -0.5;
            }

            draw(ctx) {
                const cx = this.x * TILE_SIZE + TILE_SIZE/2;
                const hoverY = Math.sin(this.tick * 0.1) * 3;
                const cy = this.y * TILE_SIZE + TILE_SIZE/2 + hoverY;
                
                // å—æƒŠå˜æˆæ·±è“è‰²
                ctx.fillStyle = this.isScared ? '#3b82f6' : this.color;
                
                // é¬¼é­‚èº«ä½“
                ctx.beginPath();
                ctx.arc(cx, cy - 4, this.radius, Math.PI, 0);
                ctx.lineTo(cx + this.radius, cy + this.radius);
                
                // åº•éƒ¨æ³¢æµª
                const waveStep = this.radius * 2 / 3;
                for(let i=1; i<=3; i++) {
                    const cpX = cx + this.radius - waveStep * (i - 0.5);
                    const endX = cx + this.radius - waveStep * i;
                    const waveY = cy + this.radius + Math.sin(this.tick * 0.2 + i) * 2;
                    ctx.quadraticCurveTo(cpX, waveY, endX, cy + this.radius);
                }
                
                ctx.lineTo(cx - this.radius, cy - 4);
                ctx.fill();
                ctx.closePath();

                // çœ¼ç›
                if (this.isScared) {
                    ctx.fillStyle = '#fbbf24'; 
                    ctx.beginPath();
                    ctx.arc(cx - 4, cy - 4, 3, 0, Math.PI*2);
                    ctx.arc(cx + 4, cy - 4, 3, 0, Math.PI*2);
                    ctx.fill();
                    ctx.strokeStyle = '#fbbf24';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(cx - 6, cy + 6);
                    ctx.lineTo(cx - 3, cy + 2);
                    ctx.lineTo(cx, cy + 6);
                    ctx.lineTo(cx + 3, cy + 2);
                    ctx.lineTo(cx + 6, cy + 6);
                    ctx.stroke();
                } else {
                    ctx.fillStyle = '#fff';
                    ctx.beginPath();
                    ctx.ellipse(cx - 4, cy - 6, 4, 5, 0, 0, Math.PI*2);
                    ctx.ellipse(cx + 4, cy - 6, 4, 5, 0, 0, Math.PI*2);
                    ctx.fill();
                    
                    ctx.fillStyle = '#1e293b';
                    const lookX = this.dir.x * 1.5;
                    const lookY = this.dir.y * 1.5;
                    ctx.beginPath();
                    ctx.arc(cx - 4 + lookX, cy - 6 + lookY, 2, 0, Math.PI*2);
                    ctx.arc(cx + 4 + lookX, cy - 6 + lookY, 2, 0, Math.PI*2);
                    ctx.fill();
                }
            }

            resetGhost() {
                this.resetPos();
                this.dir = {x: 0, y: -1}; // é‡ç”Ÿåç«‹å³å‘ä¸Šå‡ºé—¨ï¼Œé˜²æ­¢å¡æ­»
                this.lastDecisionX = -1;
                this.lastDecisionY = -1;
                this.isScared = false;
            }
        }

        class AudioController {
            constructor() {
                this.ctx = new (window.AudioContext || window.webkitAudioContext)();
                this.enabled = true;
            }

            resume() {
                if (!this.enabled || !this.ctx) return;
                if (this.ctx.state === 'suspended') {
                    this.ctx.resume();
                }
            }

            playTone(freq, type, duration, startTime = 0) {
                if (!this.enabled) return;
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.type = type;
                osc.frequency.setValueAtTime(freq, this.ctx.currentTime + startTime);
                gain.gain.setValueAtTime(0.1, this.ctx.currentTime + startTime);
                gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + startTime + duration);
                osc.connect(gain);
                gain.connect(this.ctx.destination);
                osc.start(this.ctx.currentTime + startTime);
                osc.stop(this.ctx.currentTime + startTime + duration);
            }

            playWaka() {
                // ç»å…¸çš„åŒéŸ³ Waka
                this.playTone(200, 'triangle', 0.1);
                this.playTone(300, 'triangle', 0.1, 0.1);
            }

            playPower() {
                // å¤§åŠ›ä¸¸ï¼šé«˜é¢‘é¢¤éŸ³
                this.playTone(600, 'sine', 0.3);
                this.playTone(800, 'square', 0.3, 0.1);
            }

            playEatGhost() {
                // ä¸Šå‡ç¶éŸ³
                this.playTone(400, 'square', 0.1);
                this.playTone(600, 'square', 0.1, 0.1);
                this.playTone(800, 'square', 0.1, 0.2);
                this.playTone(1200, 'square', 0.2, 0.3);
            }

            playDie() {
                // ä¸‹å æ»‘éŸ³ (æ¨¡æ‹Ÿ)
                for (let i = 0; i < 10; i++) {
                    this.playTone(500 - i * 50, 'sawtooth', 0.1, i * 0.1);
                }
            }

            playWin() {
                // èƒœåˆ©æ—‹å¾‹
                [523, 659, 784, 1046, 784, 1046].forEach((freq, i) => {
                    this.playTone(freq, 'square', 0.2, i * 0.15);
                });
            }
        }

        class Game {
            constructor() {
                this.canvas = document.getElementById('gameCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.map = [];
                this.pellets = [];
                this.walls = [];
                this.particles = [];
                
                this.score = 0;
                this.level = 1;
                this.lives = 3; 
                this.maxLevelReached = Math.min(parseInt(localStorage.getItem('pacman_max_level')) || 1, RUN_MAX_LEVEL);
                this.highScore = parseInt(localStorage.getItem('pacman_high_score')) || 0;
                this.bestRunLevel = Math.min(parseInt(localStorage.getItem('pacman_best_run_level')) || 1, RUN_MAX_LEVEL);
                this.runHighest = 0;
                this.mode = 'FREE'; // FREE æˆ– RUN
                this.scaredTimer = 0;

                this.state = 'MENU'; 

                this.player = null;
                this.ghosts = [];
                this.loopId = null;
                this.audio = new AudioController(); // å®ä¾‹åŒ–éŸ³é¢‘æ§åˆ¶å™¨
                this.setupAudioUnlock(); // ç¡®ä¿é¦–æ¬¡äº¤äº’åéŸ³é¢‘å¯ç”¨

                this.initMap(getMapForLevel(1));
                this.setupInputs();
                this.updateHUD();
                
                this.showMenu(); // åˆå§‹æ˜¾ç¤ºèœå•
                this.loop(); // å¯åŠ¨å¾ªç¯ï¼ˆç”¨äºæ¸²æŸ“èƒŒæ™¯æˆ–èœå•åŠ¨ç”»ï¼Œè¿™é‡Œä¸»è¦ç”¨ loop é‡Œçš„ state åˆ¤æ–­ï¼‰
            }

            initMap(rawMap) {
                this.map = JSON.parse(JSON.stringify(rawMap));
                this.canvas.width = this.map[0].length * TILE_SIZE;
                this.canvas.height = this.map.length * TILE_SIZE;
            }

            // --- UI æ§åˆ¶ ---

            hideAllScreens() {
                document.querySelectorAll('.overlay').forEach(el => el.classList.add('hidden'));
                document.getElementById('pause-btn').style.display = 'none';
            }

            showMenu() {
                this.state = 'MENU';
                this.hideAllScreens();
                document.getElementById('screen-menu').classList.remove('hidden');
                document.getElementById('menu-max-level').innerText = this.maxLevelReached;
                document.getElementById('menu-best-run').innerText = this.bestRunLevel;
                // åœ¨èœå•ç•Œé¢ä¹Ÿå¯ä»¥ç”»ä¸€ä¸‹é™æ€èƒŒæ™¯
                this.draw();
            }

            showRules() {
                this.hideAllScreens();
                document.getElementById('screen-rules').classList.remove('hidden');
            }

            showLevelSelect() {
                this.hideAllScreens();
                const grid = document.getElementById('level-grid');
                grid.innerHTML = '';
                
                // ç”Ÿæˆ 1~20 å…³å¡æŒ‰é’®
                for (let i = 1; i <= RUN_MAX_LEVEL; i++) {
                    const btn = document.createElement('button');
                    btn.className = 'level-btn';
                    btn.innerText = i;
                    if (i > this.maxLevelReached) {
                        btn.classList.add('locked');
                        btn.innerHTML = '<svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor"><path d="M18 8h-1V6c0-2.76-2.24-5-5-5S7 3.24 7 6v2H6c-1.1 0-2 .9-2 2v10c0 1.1.9 2 2 2h12c1.1 0 2-.9 2-2V10c0-1.1-.9-2-2-2zm-6 9c-1.1 0-2-.9-2-2s.9-2 2-2 2 .9 2 2-.9 2-2 2zm3.1-9H8.9V6c0-1.71 1.39-3 3.1-3s3.1 1.29 3.1 3v2z"/></svg>';
                    } else {
                        btn.onclick = () => this.startNewGame(i, 'FREE');
                    }
                    grid.appendChild(btn);
                }
                document.getElementById('screen-levels').classList.remove('hidden');
            }

            // --- æ¸¸æˆæµç¨‹ ---

            startNewGame(startLevel = 1, mode = 'FREE') {
                this.mode = mode;
                this.level = startLevel;
                this.score = 0;
                this.lives = 3;
                this.runHighest = this.mode === 'RUN' ? startLevel : 0;
                this.updateHUD();
                this.startLevel(true);
            }

            startFullRun() {
                this.startNewGame(1, 'RUN');
            }

            restartGame() {
                // å…¨ç¨‹æ¨¡å¼ä»ç¬¬ 1 å…³é‡å¼€ï¼›æ™®é€šæ¨¡å¼é‡ç½®å½“å‰å…³å¡
                if (this.mode === 'RUN') {
                    this.startNewGame(1, 'RUN');
                } else {
                    this.restartLevel();
                }
            }

            restartLevel() {
                // å…³å¡é‡ç½®ï¼šæ™®é€šæ¨¡å¼ä¿ç•™åˆ†æ•°ã€å›æ»¡è¡€å¹¶é‡ç½®æœ¬å…³ï¼›å…¨ç¨‹æ¨¡å¼ç›´æ¥å›åˆ°ç¬¬1å…³é‡æ–°å¼€å§‹
                if (this.mode === 'RUN') {
                    this.startNewGame(1, 'RUN');
                    return;
                }
                this.score = 0; // æ™®é€šæ¨¡å¼é‡ç½®åˆ†æ•°
                this.lives = 3;
                this.updateHUD();
                this.startLevel(true); // é‡ç½®å½“å‰å…³å¡è±†å­å’Œå®ä½“
            }

            startLevel(respawnPellets) {
                if (respawnPellets) {
                    this.initMap(getMapForLevel(this.level));
                }
                this.resetEntities(respawnPellets);
                if (this.mode === 'RUN') {
                    this.runHighest = Math.max(this.runHighest || 0, this.level);
                    this.updateRunRecord();
                }
                this.state = 'READY';
                this.hideAllScreens();
                document.getElementById('pause-btn').style.display = 'flex';

                this.draw(); 
                const msg = document.getElementById('msg-float');
                msg.innerText = respawnPellets ? `ç¬¬ ${this.level} å…³` : "å‡†å¤‡"; 
                msg.style.display = 'block';
                
                setTimeout(() => { 
                    if (this.state !== 'READY') return; // é˜²æ­¢ä¸­é€”é€€å‡º
                    if (respawnPellets) msg.innerText = "å‡†å¤‡"; 
                }, 1000);
                
                setTimeout(() => { 
                    if (this.state !== 'READY') return;
                    msg.innerText = "å¼€å§‹ï¼"; 
                }, 2000);
                
                setTimeout(() => { 
                    if (this.state !== 'READY') return;
                    msg.style.display = 'none'; 
                    this.state = 'PLAYING';
                }, 2500);
            }

            pauseGame() {
                if (this.state === 'PLAYING') {
                    this.state = 'PAUSED';
                    document.getElementById('screen-paused').classList.remove('hidden');
                }
            }

            resumeGame() {
                if (this.state === 'PAUSED') {
                    this.state = 'PLAYING';
                    document.getElementById('screen-paused').classList.add('hidden');
                }
            }

            quitToMenu() {
                this.showMenu();
            }

            resetEntities(respawnPellets = false) {
                this.walls = [];
                this.ghosts = [];
                this.particles = [];
                
                if (respawnPellets) this.pellets = [];

                for (let y = 0; y < this.map.length; y++) {
                    for (let x = 0; x < this.map[y].length; x++) {
                        const type = this.map[y][x];
                        if (type === 1) this.walls.push({x, y});
                        
                        // æ™®é€šè±†å­ (0)
                        if (respawnPellets && type === 0) this.pellets.push({x, y, active: true, power: false});
                        // å¤§åŠ›ä¸¸ (3)
                        if (respawnPellets && type === 3) this.pellets.push({x, y, active: true, power: true});
                        
                        if (type === 9) {
                            const colors = ['#f87171', '#c084fc', '#38bdf8', '#fb923c', '#4ade80'];
                            let maxGhosts = 3;
                            if (this.level >= 3) maxGhosts = 4;
                            if (this.level >= 5) maxGhosts = 5;

                            while (this.ghosts.length < maxGhosts) {
                                this.ghosts.push(new Ghost(x, y, colors[this.ghosts.length % colors.length]));
                            }
                        }
                    }
                }

                this.player = new Pacman(9, 16);
                const speedMult = 1 + (this.level - 1) * 0.03; 
                this.player.speed = Math.min(BASE_SPEED * speedMult, 0.08);
                this.ghosts.forEach(g => g.speed = Math.min((BASE_SPEED * 0.6) * speedMult, 0.06));
            }

            update() {
                if (this.state === 'PLAYING') {
                    this.player.update();
                    this.ghosts.forEach(g => g.update());

                    // 1. æ›´æ–°å—æƒŠå€’è®¡æ—¶
                    if (this.scaredTimer > 0) {
                        this.scaredTimer--;
                        if (this.scaredTimer === 0) {
                            this.ghosts.forEach(g => g.isScared = false);
                        }
                    }

                    for(let i = this.particles.length - 1; i >= 0; i--) {
                        this.particles[i].update();
                        if(this.particles[i].life <= 0) this.particles.splice(i, 1);
                    }

                    // 2. åƒè±†æ£€æµ‹
                    const px = Math.round(this.player.x);
                    const py = Math.round(this.player.y);
                    const pIndex = this.pellets.findIndex(p => p.x === px && p.y === py && p.active);
                    
                    if (pIndex !== -1) {
                    const pellet = this.pellets[pIndex];
                    pellet.active = false;
                    this.score += 10;
                    this.player.scale = 1.3; 
                    
                    // --- åƒå¤§åŠ›ä¸¸é€»è¾‘ ---
                    if (pellet.power) {
                        this.scaredTimer = 600; // 10ç§’
                        this.ghosts.forEach(g => g.isScared = true);
                        this.score += 40;
                        this.audio.playPower();
                    } else {
                        this.audio.playWaka();
                    }
                    this.updateHUD();

                    // åƒè±†ç‰¹æ•ˆ
                    for(let k=0; k<4; k++) {
                        this.particles.push(new Particle(
                            px * TILE_SIZE + TILE_SIZE/2,
                                py * TILE_SIZE + TILE_SIZE/2,
                                pellet.power ? '#ff00ff' : '#fff', 
                                pellet.power ? 8 : 5
                            ));
                        }
                        if (this.pellets.every(p => !p.active)) {
                            this.levelComplete();
                        }
                    }

                    // 3. é¬¼é­‚ç¢°æ’æ£€æµ‹
                    for (let g of this.ghosts) {
                        const dist = Math.hypot(this.player.x - g.x, this.player.y - g.y);
                        if (dist < 0.6) {
                            // --- åæ€é€»è¾‘ ---
                            if (g.isScared) {
                                // åƒæ‰é¬¼é­‚ï¼
                                // ç›´æ¥é‡ç½®çŠ¶æ€ï¼Œä¸è°ƒç”¨æ–¹æ³•ä»¥é˜²ä¸‡ä¸€
                                g.x = g.startX;
                                g.y = g.startY;
                                g.dir = {x: 0, y: -1}; // å‘ä¸Šå‡ºé—¨
                                g.nextDir = {x:0, y:0};
                                g.lastDecisionX = -1;
                                g.lastDecisionY = -1;
                                g.isScared = false; 
                                
                                this.score += 200;
                                this.updateHUD();
                                
                                this.audio.playEatGhost();
                                
                                // åƒé¬¼ç‰¹æ•ˆ (è“è‰²çˆ†ç‚¸)
                                for(let i=0; i<20; i++) {
                                    this.particles.push(new Particle(
                                        this.player.x * TILE_SIZE + TILE_SIZE/2,
                                        this.player.y * TILE_SIZE + TILE_SIZE/2,
                                        '#3b82f6', 6
                                    ));
                                }
                            } else {
                                // è¢«é¬¼é­‚åƒæ‰
                                this.deathSequence();
                                return;
                            }
                        }
                    }
                } else if (this.state === 'DYING') {
                    for(let i = this.particles.length - 1; i >= 0; i--) {
                        this.particles[i].update();
                        if(this.particles[i].life <= 0) this.particles.splice(i, 1);
                    }
                }
            }

            deathSequence() {
                this.state = 'DYING';
                this.lives--;
                this.updateHUD();
                this.audio.playDie();

                for(let i=0; i<30; i++) {
                    this.particles.push(new Particle(
                        this.player.x * TILE_SIZE + TILE_SIZE/2,
                        this.player.y * TILE_SIZE + TILE_SIZE/2,
                        '#fbbf24', 8
                    ));
                }
                
                setTimeout(() => {
                    if (this.state !== 'DYING') return; // é˜²æ­¢ä¸­é€”é€€å‡º
                    if (this.lives > 0) {
                        this.startLevel(false); 
                    } else {
                        this.gameOver();
                    }
                }, 1500);
            }

            levelComplete() {
                this.state = 'LEVEL_TRANSITION';
                this.pellets = []; 
                this.audio.playWin();
                const nextLevel = Math.min(this.level + 1, RUN_MAX_LEVEL);
                // è§£é”æ–°å…³å¡
                if (nextLevel > this.maxLevelReached) {
                    this.maxLevelReached = nextLevel;
                    localStorage.setItem('pacman_max_level', this.maxLevelReached);
                }

                if (this.mode === 'RUN') {
                    this.runHighest = Math.max(this.runHighest, this.level);
                    this.updateRunRecord();
                    if (this.level >= RUN_MAX_LEVEL) {
                        this.runComplete();
                        return;
                    }
                }
                document.getElementById('next-level-num').innerText = nextLevel;
                document.getElementById('screen-levelup').classList.remove('hidden');
                
                setTimeout(() => {
                    if (this.state !== 'LEVEL_TRANSITION') return;
                    document.getElementById('screen-levelup').classList.add('hidden');
                    this.level = nextLevel;
                    this.startLevel(true);
                }, 3000);
            }

            runComplete() {
                this.state = 'RUN_COMPLETE';
                this.updateRunRecord();
                this.updateHUD();
                document.getElementById('runcomplete-level').innerText = this.runHighest;
                document.getElementById('runcomplete-score').innerText = this.score;
                document.getElementById('runcomplete-best').innerText = this.bestRunLevel;
                document.getElementById('screen-levelup').classList.add('hidden');
                document.getElementById('screen-runcomplete').classList.remove('hidden');
                document.getElementById('pause-btn').style.display = 'none';
            }

            gameOver() {
                this.state = 'GAMEOVER';
                this.updateRunRecord();
                this.updateHUD();
                document.getElementById('end-score').innerText = this.score;
                const runBestRow = document.getElementById('end-run-best');
                if (this.mode === 'RUN') {
                    document.getElementById('end-run-best-value').innerText = this.bestRunLevel;
                    runBestRow.classList.remove('hidden');
                } else {
                    runBestRow.classList.add('hidden');
                }
                document.getElementById('screen-gameover').classList.remove('hidden');
                document.getElementById('pause-btn').style.display = 'none';
            }

            draw() {
                // å¦‚æœåœ¨èœå•çŠ¶æ€ï¼Œä¹Ÿå¯ä»¥ç”»èƒŒæ™¯
                const theme = LEVEL_THEMES[(this.level - 1) % LEVEL_THEMES.length];
                this.ctx.fillStyle = theme.bg;
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

                // Draw Walls 
                this.ctx.fillStyle = theme.wall;
                this.walls.forEach(w => {
                    const cx = w.x * TILE_SIZE;
                    const cy = w.y * TILE_SIZE;
                    const size = TILE_SIZE;
                    const pad = 0; 
                    this.ctx.beginPath();
                    this.ctx.roundRect(cx + pad, cy + pad, size - pad*2, size - pad*2, 8);
                    this.ctx.fill();
                });

                // Draw Pellets
                this.pellets.forEach(p => {
                    if (p.active) {
                        this.ctx.beginPath();
                        if (p.power) {
                            // å¤§åŠ›ä¸¸ï¼šé—ªçƒå¤§çƒ
                            const pulse = Math.sin(this.player ? this.player.tick * 0.2 : Date.now() * 0.01) * 2;
                            this.ctx.fillStyle = '#ff00ff'; // éœ“è™¹ç²‰
                            this.ctx.arc(p.x * TILE_SIZE + TILE_SIZE/2, p.y * TILE_SIZE + TILE_SIZE/2, 7 + pulse, 0, Math.PI*2);
                            this.ctx.shadowBlur = 15;
                            this.ctx.shadowColor = '#ff00ff';
                            this.ctx.fill();
                            this.ctx.shadowBlur = 0;
                        } else {
                            // æ™®é€šè±†å­
                            this.ctx.fillStyle = '#fbbf24';
                            this.ctx.arc(p.x * TILE_SIZE + TILE_SIZE/2, p.y * TILE_SIZE + TILE_SIZE/2, 5, 0, Math.PI*2);
                            this.ctx.fill();
                        }
                    }
                });

                this.particles.forEach(p => p.draw(this.ctx));

                if (this.state !== 'MENU' && this.state !== 'GAMEOVER_SCREEN' && this.player) {
                    if (this.state !== 'DYING') this.player.draw(this.ctx);
                    this.ghosts.forEach(g => g.draw(this.ctx));
                }
            }

            loop() {
                // ä¸»å¾ªç¯å§‹ç»ˆè¿è¡Œï¼Œæ ¹æ®çŠ¶æ€å†³å®š update
                if (this.state === 'PLAYING' || this.state === 'DYING') {
                    this.update();
                }
                this.draw(); // å§‹ç»ˆç»˜åˆ¶ï¼Œä¿æŒç”»é¢ä¸æ¶ˆå¤±ï¼ˆæš‚åœæ—¶ä¹Ÿèƒ½çœ‹åˆ°å®šæ ¼ç”»é¢ï¼‰
                this.loopId = requestAnimationFrame(() => this.loop());
            }

            updateHighScore() {
                if (this.score > this.highScore) {
                    this.highScore = this.score;
                    localStorage.setItem('pacman_high_score', this.highScore);
                }
            }

            updateRunRecord() {
                if (this.mode !== 'RUN') return;
                if (this.runHighest > this.bestRunLevel) {
                    this.bestRunLevel = this.runHighest;
                    localStorage.setItem('pacman_best_run_level', this.bestRunLevel);
                    const menuRun = document.getElementById('menu-best-run');
                    if (menuRun) menuRun.innerText = this.bestRunLevel;
                }
            }

            updateHUD() {
                this.updateHighScore();
                document.getElementById('ui-score').innerText = this.score;
                document.getElementById('ui-level').innerText = this.level;
                const hearts = 'â¤ï¸'.repeat(Math.max(0, this.lives));
                document.getElementById('ui-lives').innerText = hearts;
                document.getElementById('ui-high-score').innerText = `æœ€é«˜ ${this.highScore}`;
                const runBadge = document.getElementById('ui-run-mode');
                if (this.mode === 'RUN') {
                    runBadge.innerText = `å…¨ç¨‹ 1â†’${RUN_MAX_LEVEL}`;
                    runBadge.classList.remove('hidden');
                } else {
                    runBadge.classList.add('hidden');
                }
            }

            setupAudioUnlock() {
                const unlock = () => {
                    this.audio.resume();
                    ['click', 'keydown', 'touchstart'].forEach(evt => document.removeEventListener(evt, unlock));
                };
                ['click', 'keydown', 'touchstart'].forEach(evt => {
                    document.addEventListener(evt, unlock, { once: true });
                });
            }

            setupInputs() {
                document.addEventListener('keydown', (e) => {
                    // åªæœ‰æ¸¸æˆä¸­æ‰å“åº”ç§»åŠ¨ï¼Œæš‚åœæˆ–èœå•ä¸å“åº”
                    if (this.state !== 'PLAYING') return;
                    if(['ArrowUp','ArrowDown','ArrowLeft','ArrowRight'].indexOf(e.code) > -1) e.preventDefault();

                    switch(e.key) {
                        case 'ArrowUp': this.player.nextDir = {x: 0, y: -1}; break;
                        case 'ArrowDown': this.player.nextDir = {x: 0, y: 1}; break;
                        case 'ArrowLeft': this.player.nextDir = {x: -1, y: 0}; break;
                        case 'ArrowRight': this.player.nextDir = {x: 1, y: 0}; break;
                    }
                });
            }
        }

        const game = new Game();

    </script>
</body>
</html>
